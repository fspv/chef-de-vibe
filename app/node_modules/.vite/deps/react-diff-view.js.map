{
  "version": 3,
  "sources": ["../../react-diff-view/node_modules/classnames/index.js", "../../react-diff-view/src/context/index.ts", "../../react-diff-view/node_modules/gitdiff-parser/index.js", "../../react-diff-view/src/utils/parse.ts", "../../react-diff-view/src/utils/diff/util.ts", "../../react-diff-view/src/utils/diff/factory.ts", "../../react-diff-view/node_modules/lodash/_baseFindIndex.js", "../../react-diff-view/node_modules/lodash/_listCacheClear.js", "../../react-diff-view/node_modules/lodash/eq.js", "../../react-diff-view/node_modules/lodash/_assocIndexOf.js", "../../react-diff-view/node_modules/lodash/_listCacheDelete.js", "../../react-diff-view/node_modules/lodash/_listCacheGet.js", "../../react-diff-view/node_modules/lodash/_listCacheHas.js", "../../react-diff-view/node_modules/lodash/_listCacheSet.js", "../../react-diff-view/node_modules/lodash/_ListCache.js", "../../react-diff-view/node_modules/lodash/_stackClear.js", "../../react-diff-view/node_modules/lodash/_stackDelete.js", "../../react-diff-view/node_modules/lodash/_stackGet.js", "../../react-diff-view/node_modules/lodash/_stackHas.js", "../../react-diff-view/node_modules/lodash/_freeGlobal.js", "../../react-diff-view/node_modules/lodash/_root.js", "../../react-diff-view/node_modules/lodash/_Symbol.js", "../../react-diff-view/node_modules/lodash/_getRawTag.js", "../../react-diff-view/node_modules/lodash/_objectToString.js", "../../react-diff-view/node_modules/lodash/_baseGetTag.js", "../../react-diff-view/node_modules/lodash/isObject.js", "../../react-diff-view/node_modules/lodash/isFunction.js", "../../react-diff-view/node_modules/lodash/_coreJsData.js", "../../react-diff-view/node_modules/lodash/_isMasked.js", "../../react-diff-view/node_modules/lodash/_toSource.js", "../../react-diff-view/node_modules/lodash/_baseIsNative.js", "../../react-diff-view/node_modules/lodash/_getValue.js", "../../react-diff-view/node_modules/lodash/_getNative.js", "../../react-diff-view/node_modules/lodash/_Map.js", "../../react-diff-view/node_modules/lodash/_nativeCreate.js", "../../react-diff-view/node_modules/lodash/_hashClear.js", "../../react-diff-view/node_modules/lodash/_hashDelete.js", "../../react-diff-view/node_modules/lodash/_hashGet.js", "../../react-diff-view/node_modules/lodash/_hashHas.js", "../../react-diff-view/node_modules/lodash/_hashSet.js", "../../react-diff-view/node_modules/lodash/_Hash.js", "../../react-diff-view/node_modules/lodash/_mapCacheClear.js", "../../react-diff-view/node_modules/lodash/_isKeyable.js", "../../react-diff-view/node_modules/lodash/_getMapData.js", "../../react-diff-view/node_modules/lodash/_mapCacheDelete.js", "../../react-diff-view/node_modules/lodash/_mapCacheGet.js", "../../react-diff-view/node_modules/lodash/_mapCacheHas.js", "../../react-diff-view/node_modules/lodash/_mapCacheSet.js", "../../react-diff-view/node_modules/lodash/_MapCache.js", "../../react-diff-view/node_modules/lodash/_stackSet.js", "../../react-diff-view/node_modules/lodash/_Stack.js", "../../react-diff-view/node_modules/lodash/_setCacheAdd.js", "../../react-diff-view/node_modules/lodash/_setCacheHas.js", "../../react-diff-view/node_modules/lodash/_SetCache.js", "../../react-diff-view/node_modules/lodash/_arraySome.js", "../../react-diff-view/node_modules/lodash/_cacheHas.js", "../../react-diff-view/node_modules/lodash/_equalArrays.js", "../../react-diff-view/node_modules/lodash/_Uint8Array.js", "../../react-diff-view/node_modules/lodash/_mapToArray.js", "../../react-diff-view/node_modules/lodash/_setToArray.js", "../../react-diff-view/node_modules/lodash/_equalByTag.js", "../../react-diff-view/node_modules/lodash/_arrayPush.js", "../../react-diff-view/node_modules/lodash/isArray.js", "../../react-diff-view/node_modules/lodash/_baseGetAllKeys.js", "../../react-diff-view/node_modules/lodash/_arrayFilter.js", "../../react-diff-view/node_modules/lodash/stubArray.js", "../../react-diff-view/node_modules/lodash/_getSymbols.js", "../../react-diff-view/node_modules/lodash/_baseTimes.js", "../../react-diff-view/node_modules/lodash/isObjectLike.js", "../../react-diff-view/node_modules/lodash/_baseIsArguments.js", "../../react-diff-view/node_modules/lodash/isArguments.js", "../../react-diff-view/node_modules/lodash/stubFalse.js", "../../react-diff-view/node_modules/lodash/isBuffer.js", "../../react-diff-view/node_modules/lodash/_isIndex.js", "../../react-diff-view/node_modules/lodash/isLength.js", "../../react-diff-view/node_modules/lodash/_baseIsTypedArray.js", "../../react-diff-view/node_modules/lodash/_baseUnary.js", "../../react-diff-view/node_modules/lodash/_nodeUtil.js", "../../react-diff-view/node_modules/lodash/isTypedArray.js", "../../react-diff-view/node_modules/lodash/_arrayLikeKeys.js", "../../react-diff-view/node_modules/lodash/_isPrototype.js", "../../react-diff-view/node_modules/lodash/_overArg.js", "../../react-diff-view/node_modules/lodash/_nativeKeys.js", "../../react-diff-view/node_modules/lodash/_baseKeys.js", "../../react-diff-view/node_modules/lodash/isArrayLike.js", "../../react-diff-view/node_modules/lodash/keys.js", "../../react-diff-view/node_modules/lodash/_getAllKeys.js", "../../react-diff-view/node_modules/lodash/_equalObjects.js", "../../react-diff-view/node_modules/lodash/_DataView.js", "../../react-diff-view/node_modules/lodash/_Promise.js", "../../react-diff-view/node_modules/lodash/_Set.js", "../../react-diff-view/node_modules/lodash/_WeakMap.js", "../../react-diff-view/node_modules/lodash/_getTag.js", "../../react-diff-view/node_modules/lodash/_baseIsEqualDeep.js", "../../react-diff-view/node_modules/lodash/_baseIsEqual.js", "../../react-diff-view/node_modules/lodash/_baseIsMatch.js", "../../react-diff-view/node_modules/lodash/_isStrictComparable.js", "../../react-diff-view/node_modules/lodash/_getMatchData.js", "../../react-diff-view/node_modules/lodash/_matchesStrictComparable.js", "../../react-diff-view/node_modules/lodash/_baseMatches.js", "../../react-diff-view/node_modules/lodash/isSymbol.js", "../../react-diff-view/node_modules/lodash/_isKey.js", "../../react-diff-view/node_modules/lodash/memoize.js", "../../react-diff-view/node_modules/lodash/_memoizeCapped.js", "../../react-diff-view/node_modules/lodash/_stringToPath.js", "../../react-diff-view/node_modules/lodash/_arrayMap.js", "../../react-diff-view/node_modules/lodash/_baseToString.js", "../../react-diff-view/node_modules/lodash/toString.js", "../../react-diff-view/node_modules/lodash/_castPath.js", "../../react-diff-view/node_modules/lodash/_toKey.js", "../../react-diff-view/node_modules/lodash/_baseGet.js", "../../react-diff-view/node_modules/lodash/get.js", "../../react-diff-view/node_modules/lodash/_baseHasIn.js", "../../react-diff-view/node_modules/lodash/_hasPath.js", "../../react-diff-view/node_modules/lodash/hasIn.js", "../../react-diff-view/node_modules/lodash/_baseMatchesProperty.js", "../../react-diff-view/node_modules/lodash/identity.js", "../../react-diff-view/node_modules/lodash/_baseProperty.js", "../../react-diff-view/node_modules/lodash/_basePropertyDeep.js", "../../react-diff-view/node_modules/lodash/property.js", "../../react-diff-view/node_modules/lodash/_baseIteratee.js", "../../react-diff-view/node_modules/lodash/_trimmedEndIndex.js", "../../react-diff-view/node_modules/lodash/_baseTrim.js", "../../react-diff-view/node_modules/lodash/toNumber.js", "../../react-diff-view/node_modules/lodash/toFinite.js", "../../react-diff-view/node_modules/lodash/toInteger.js", "../../react-diff-view/node_modules/lodash/findLastIndex.js", "../../react-diff-view/src/utils/diff/insertHunk.ts", "../../react-diff-view/src/utils/diff/getChangeKey.ts", "../../react-diff-view/src/utils/diff/expandCollapsedBlockBy.ts", "../../react-diff-view/src/utils/diff/index.ts", "../../react-diff-view/node_modules/lodash/_defineProperty.js", "../../react-diff-view/node_modules/lodash/_baseAssignValue.js", "../../react-diff-view/node_modules/lodash/_createBaseFor.js", "../../react-diff-view/node_modules/lodash/_baseFor.js", "../../react-diff-view/node_modules/lodash/_baseForOwn.js", "../../react-diff-view/node_modules/lodash/mapValues.js", "../../react-diff-view/src/Hunk/CodeCell.tsx", "../../react-diff-view/src/Hunk/utils.tsx", "../../react-diff-view/src/Hunk/UnifiedHunk/UnifiedChange.tsx", "../../react-diff-view/src/Hunk/UnifiedHunk/UnifiedWidget.tsx", "../../react-diff-view/src/Hunk/UnifiedHunk/index.tsx", "../../react-diff-view/src/Hunk/SplitHunk/SplitChange.tsx", "../../react-diff-view/src/Hunk/SplitHunk/SplitWidget.tsx", "../../react-diff-view/src/Hunk/SplitHunk/index.tsx", "../../react-diff-view/src/Hunk/index.tsx", "../../react-diff-view/src/Diff/index.tsx", "../../react-diff-view/node_modules/warning/warning.js", "../../react-diff-view/src/Decoration/SplitDecoration.tsx", "../../react-diff-view/src/Decoration/UnifiedDecoration.tsx", "../../react-diff-view/src/Decoration/index.tsx", "../../react-diff-view/node_modules/lodash/_arrayAggregator.js", "../../react-diff-view/node_modules/lodash/_createBaseEach.js", "../../react-diff-view/node_modules/lodash/_baseEach.js", "../../react-diff-view/node_modules/lodash/_baseAggregator.js", "../../react-diff-view/node_modules/lodash/_createAggregator.js", "../../react-diff-view/node_modules/lodash/keyBy.js", "../../react-diff-view/node_modules/lodash/_isFlattenable.js", "../../react-diff-view/node_modules/lodash/_baseFlatten.js", "../../react-diff-view/node_modules/lodash/_baseMap.js", "../../react-diff-view/node_modules/lodash/map.js", "../../react-diff-view/node_modules/lodash/flatMap.js", "../../react-diff-view/src/tokenize/toTokenTrees.ts", "../../react-diff-view/src/tokenize/utils.ts", "../../react-diff-view/src/tokenize/normalizeToLines.ts", "../../react-diff-view/node_modules/lodash/isEqualWith.js", "../../react-diff-view/node_modules/lodash/isEqual.js", "../../react-diff-view/node_modules/lodash/last.js", "../../react-diff-view/src/tokenize/backToTree.ts", "../../react-diff-view/node_modules/lodash/groupBy.js", "../../react-diff-view/node_modules/lodash/isEmpty.js", "../../react-diff-view/src/tokenize/pickRanges.ts", "../../react-diff-view/node_modules/lodash/flatten.js", "../../react-diff-view/node_modules/lodash/findIndex.js", "../../react-diff-view/node_modules/diff-match-patch/index.js", "../../react-diff-view/src/tokenize/markEdits.ts", "../../react-diff-view/src/tokenize/markWord.ts", "../../react-diff-view/src/tokenize/index.ts", "../../react-diff-view/src/hooks/useMinCollapsedLines.ts", "../../react-diff-view/src/hooks/helpers.ts", "../../react-diff-view/src/hooks/useChangeSelect.ts", "../../react-diff-view/src/hooks/useSourceExpansion.ts", "../../react-diff-view/node_modules/shallow-equal/src/objects.ts", "../../react-diff-view/src/hooks/useTokenizeWorker.ts", "../../react-diff-view/node_modules/shallow-equal/src/arrays.ts", "../../react-diff-view/src/hocs/wrapDisplayName.ts", "../../react-diff-view/src/hocs/withSourceExpansion.tsx", "../../react-diff-view/src/hocs/minCollapsedLines.tsx", "../../react-diff-view/src/hocs/withChangeSelect.tsx", "../../react-diff-view/src/hocs/withTokenizeWorker.tsx"],
  "sourcesContent": ["/*!\n\tCopyright (c) 2018 Jed Watson.\n\tLicensed under the MIT License (MIT), see\n\thttp://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar hasOwn = {}.hasOwnProperty;\n\tvar nativeCodeString = '[native code]';\n\n\tfunction classNames() {\n\t\tvar classes = [];\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar arg = arguments[i];\n\t\t\tif (!arg) continue;\n\n\t\t\tvar argType = typeof arg;\n\n\t\t\tif (argType === 'string' || argType === 'number') {\n\t\t\t\tclasses.push(arg);\n\t\t\t} else if (Array.isArray(arg)) {\n\t\t\t\tif (arg.length) {\n\t\t\t\t\tvar inner = classNames.apply(null, arg);\n\t\t\t\t\tif (inner) {\n\t\t\t\t\t\tclasses.push(inner);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (argType === 'object') {\n\t\t\t\tif (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes('[native code]')) {\n\t\t\t\t\tclasses.push(arg.toString());\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (var key in arg) {\n\t\t\t\t\tif (hasOwn.call(arg, key) && arg[key]) {\n\t\t\t\t\t\tclasses.push(key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn classes.join(' ');\n\t}\n\n\tif (typeof module !== 'undefined' && module.exports) {\n\t\tclassNames.default = classNames;\n\t\tmodule.exports = classNames;\n\t} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {\n\t\t// register as 'classnames', consistent with npm package name\n\t\tdefine('classnames', [], function () {\n\t\t\treturn classNames;\n\t\t});\n\t} else {\n\t\twindow.classNames = classNames;\n\t}\n}());\n", "import {createContext, DOMAttributes, ReactNode, useContext} from 'react';\nimport {ChangeData} from '../utils/parse';\nimport {HunkTokens, TokenNode} from '../tokenize';\nimport {Side} from '../interface';\n\nexport type DefaultRenderToken = (token: TokenNode, index: number) => ReactNode;\n\nexport type RenderToken = (token: TokenNode, renderDefault: DefaultRenderToken, index: number) => ReactNode;\n\nexport interface GutterOptions {\n    change: ChangeData;\n    side: Side;\n    inHoverState: boolean;\n    renderDefault: () => ReactNode;\n    wrapInAnchor: (element: ReactNode) => ReactNode;\n}\n\nexport type RenderGutter = (options: GutterOptions) => ReactNode;\n\nexport type ViewType = 'unified' | 'split';\n\nexport type GutterType = 'default' | 'none' | 'anchor';\n\ntype IsEvent<T> = T extends `on${string}` ? T : never;\n\nexport type EventKeys = IsEvent<keyof DOMAttributes<HTMLElement>>;\n\nexport type NativeEventMap = Partial<{[K in EventKeys]: DOMAttributes<HTMLElement>[K]}>;\n\ntype ExtractEventHandler<E extends EventKeys> = Exclude<NativeEventMap[E], undefined>;\n\ntype ExtractEventType<E extends EventKeys> = Parameters<ExtractEventHandler<E>>[0];\n\nexport interface ChangeEventArgs {\n    // TODO: use union type on next major version\n    side?: Side;\n    change: ChangeData | null;\n}\n\ntype BindEvent<E extends EventKeys> = (args: ChangeEventArgs, event: ExtractEventType<E>) => void;\n\nexport type EventMap = Partial<{[K in EventKeys]: BindEvent<K>}>;\n\nexport interface ContextProps {\n    hunkClassName: string;\n    lineClassName: string;\n    gutterClassName: string;\n    codeClassName: string;\n    monotonous: boolean;\n    gutterType: GutterType;\n    viewType: ViewType;\n    widgets: Record<string, ReactNode>;\n    hideGutter: boolean;\n    selectedChanges: string[];\n    tokens?: HunkTokens | null;\n    generateAnchorID: (change: ChangeData) => string | undefined;\n    generateLineClassName: (params: {changes: ChangeData[], defaultGenerate: () => string}) => string | undefined;\n    renderToken?: RenderToken;\n    renderGutter: RenderGutter;\n    gutterEvents: EventMap;\n    codeEvents: EventMap;\n}\n\nexport const DEFAULT_CONTEXT_VALUE: ContextProps = {\n    hunkClassName: '',\n    lineClassName: '',\n    gutterClassName: '',\n    codeClassName: '',\n    monotonous: false,\n    gutterType: 'default',\n    viewType: 'split',\n    widgets: {},\n    hideGutter: false,\n    selectedChanges: [],\n    generateAnchorID: () => undefined,\n    generateLineClassName: () => undefined,\n    renderGutter: ({renderDefault, wrapInAnchor}) => wrapInAnchor(renderDefault()),\n    codeEvents: {},\n    gutterEvents: {},\n};\n\nconst ContextType = createContext(DEFAULT_CONTEXT_VALUE);\n\nexport const Provider = ContextType.Provider;\n\nexport const useDiffSettings = () => useContext(ContextType);\n", "/**\n * @file gitdiff 消息解析器\n * @author errorrik(errorrik@gmail.com)\n */\n\n(function (root) {\n    var STAT_START = 2;\n    var STAT_FILE_META = 3;\n    var STAT_HUNK = 5;\n\n    function parsePathFromFirstLine(line) {\n        var filesStr = line.slice(11);\n        var oldPath = null;\n        var newPath = null;\n\n        var quoteIndex = filesStr.indexOf('\"');\n        switch (quoteIndex) {\n            case -1:\n                var segs = filesStr.split(' ');\n                oldPath = segs[0].slice(2);\n                newPath = segs[1].slice(2);\n                break;\n\n            case 0:\n                var nextQuoteIndex = filesStr.indexOf('\"', 2);\n                oldPath = filesStr.slice(3, nextQuoteIndex);\n                var newQuoteIndex = filesStr.indexOf('\"', nextQuoteIndex + 1);\n                if (newQuoteIndex < 0) {\n                    newPath = filesStr.slice(nextQuoteIndex + 4);\n                }\n                else {\n                    newPath = filesStr.slice(newQuoteIndex + 3, -1);\n                }\n                break;\n\n            default:\n                var segs = filesStr.split(' ');\n                oldPath = segs[0].slice(2);\n                newPath = segs[1].slice(3, -1);\n                break;\n        }\n\n        return {\n            oldPath: oldPath,\n            newPath: newPath\n        };\n    }\n\n\n    var parser = {\n        /**\n         * 解析 gitdiff 消息\n         *\n         * @param {string} source gitdiff消息内容\n         * @return {Object}\n         */\n        parse: function (source) {\n            var infos = [];\n            var stat = STAT_START;\n            var currentInfo;\n            var currentHunk;\n            var changeOldLine;\n            var changeNewLine;\n            var paths;\n\n\n            var lines = source.split('\\n');\n            var linesLen = lines.length;\n            var i = 0;\n\n            while (i < linesLen) {\n                var line = lines[i];\n\n                if (line.indexOf('diff --git') === 0) {\n                    // read file\n                    paths = parsePathFromFirstLine(line);\n                    currentInfo = {\n                        hunks: [],\n                        oldEndingNewLine: true,\n                        newEndingNewLine: true,\n                        oldPath: paths.oldPath,\n                        newPath: paths.newPath\n                    };\n\n                    infos.push(currentInfo);\n\n\n                    // 1. 如果oldPath是/dev/null就是add\n                    // 2. 如果newPath是/dev/null就是delete\n                    // 3. 如果有 rename from foo.js 这样的就是rename\n                    // 4. 如果有 copy from foo.js 这样的就是copy\n                    // 5. 其它情况是modify\n                    var currentInfoType = null;\n\n\n                    // read type and index\n                    var simiLine;\n                    simiLoop: while ((simiLine = lines[++i])) {\n                        var spaceIndex = simiLine.indexOf(' ');\n                        var infoType = spaceIndex > -1 ? simiLine.slice(0, spaceIndex) : infoType;\n\n                        switch (infoType) {\n                            case 'diff': // diff --git\n                                i--;\n                                break simiLoop;\n\n                            case 'deleted':\n                            case 'new':\n                                var leftStr = simiLine.slice(spaceIndex + 1);\n                                if (leftStr.indexOf('file mode') === 0) {\n                                    currentInfo[infoType === 'new' ? 'newMode' : 'oldMode'] = leftStr.slice(10);\n                                }\n                                break;\n\n                            case 'similarity':\n                                currentInfo.similarity = parseInt(simiLine.split(' ')[2], 10);\n                                break;\n\n                            case 'index':\n                                var segs = simiLine.slice(spaceIndex + 1).split(' ');\n                                var revs = segs[0].split('..');\n                                currentInfo.oldRevision = revs[0];\n                                currentInfo.newRevision = revs[1];\n\n                                if (segs[1]) {\n                                    currentInfo.oldMode = currentInfo.newMode = segs[1];\n                                }\n                                break;\n\n                            case 'copy':\n                            case 'rename':\n                                var infoStr = simiLine.slice(spaceIndex + 1);\n                                if (infoStr.indexOf('from') === 0) {\n                                    currentInfo.oldPath = infoStr.slice(5);\n                                }\n                                else { // rename to\n                                    currentInfo.newPath = infoStr.slice(3);\n                                }\n                                currentInfoType = infoType;\n                                break;\n\n                            case '---':\n                                var oldPath = simiLine.slice(spaceIndex + 1);\n                                var newPath = lines[++i].slice(4); // next line must be \"+++ xxx\"\n                                if (oldPath === '/dev/null') {\n                                    newPath = newPath.slice(2);\n                                    currentInfoType = 'add';\n                                }\n                                else if (newPath === '/dev/null') {\n                                    oldPath = oldPath.slice(2);\n                                    currentInfoType = 'delete';\n                                } else {\n                                    currentInfoType = 'modify';\n                                    oldPath = oldPath.slice(2);\n                                    newPath = newPath.slice(2);\n                                }\n\n                                if (oldPath) {\n                                    currentInfo.oldPath = oldPath;\n                                }\n                                if (newPath) {\n                                    currentInfo.newPath = newPath;\n                                }\n                                stat = STAT_HUNK;\n                                break simiLoop;\n                        }\n                    }\n\n                    currentInfo.type = currentInfoType || 'modify';\n                }\n                else if (line.indexOf('Binary') === 0) {\n                    currentInfo.isBinary = true;\n                    currentInfo.type = line.indexOf('/dev/null and') >= 0\n                        ? 'add'\n                        : (line.indexOf('and /dev/null') >= 0 ? 'delete' : 'modify');\n                    stat = STAT_START;\n                    currentInfo = null;\n                }\n                else if (stat === STAT_HUNK) {\n                    if (line.indexOf('@@') === 0) {\n                        var match = /^@@\\s+-([0-9]+)(,([0-9]+))?\\s+\\+([0-9]+)(,([0-9]+))?/.exec(line)\n                        currentHunk = {\n                            content: line,\n                            oldStart: match[1] - 0,\n                            newStart: match[4] - 0,\n                            oldLines: match[3] - 0 || 1,\n                            newLines: match[6] - 0 || 1,\n                            changes: []\n                        };\n\n                        currentInfo.hunks.push(currentHunk);\n                        changeOldLine = currentHunk.oldStart;\n                        changeNewLine = currentHunk.newStart;\n                    }\n                    else {\n                        var typeChar = line.slice(0, 1);\n                        var change = {\n                            content: line.slice(1)\n                        };\n\n                        switch (typeChar) {\n                            case '+':\n                                change.type = 'insert';\n                                change.isInsert = true;\n                                change.lineNumber = changeNewLine;\n                                changeNewLine++;\n                                break;\n\n                            case '-':\n                                change.type = 'delete';\n                                change.isDelete = true;\n                                change.lineNumber = changeOldLine;\n                                changeOldLine++;\n                                break;\n\n                            case ' ':\n                                change.type = 'normal';\n                                change.isNormal = true;\n                                change.oldLineNumber = changeOldLine;\n                                change.newLineNumber = changeNewLine;\n                                changeOldLine++;\n                                changeNewLine++;\n                                break;\n\n                            case '\\\\': // Seems \"no newline\" is the only case starting with /\n                                var lastChange = currentHunk.changes[currentHunk.changes.length - 1];\n                                if (!lastChange.isDelete) {\n                                    currentInfo.newEndingNewLine = false;\n                                }\n                                if (!lastChange.isInsert) {\n                                    currentInfo.oldEndingNewLine = false;\n                                }\n                        }\n\n                        change.type && currentHunk.changes.push(change);\n                    }\n                }\n\n                i++;\n            }\n\n            return infos;\n        }\n    };\n\n    if (typeof exports === 'object' && typeof module === 'object') {\n        // For CommonJS\n        exports = module.exports = parser;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        // For AMD\n        define('gitDiffParser', [], parser);\n    }\n    else {\n        root.gitDiffParser = parser;\n    }\n})(this);\n", "import parser, {Change, DeleteChange, File, Hunk, InsertChange, NormalChange} from 'gitdiff-parser';\n\nexport function isInsert(change: Change): change is InsertChange {\n    return change.type === 'insert';\n}\n\nexport function isDelete(change: Change): change is DeleteChange {\n    return change.type === 'delete';\n}\n\nexport function isNormal(change: Change): change is NormalChange {\n    return change.type === 'normal';\n}\n\nexport type {File as FileData, Hunk as HunkData, Change as ChangeData};\n\nexport interface ParseOptions {\n    nearbySequences?: 'zip';\n}\n\nfunction zipChanges(changes: Change[]) {\n    const [result] = changes.reduce<[Change[], Change | null, number]>(\n        ([result, last, lastDeletionIndex], current, i) => {\n            if (!last) {\n                result.push(current);\n                return [result, current, isDelete(current) ? i : -1];\n            }\n\n            if (isInsert(current) && lastDeletionIndex >= 0) {\n                result.splice(lastDeletionIndex + 1, 0, current);\n                // The new `lastDeletionIndex` may be out of range, but `splice` will fix it\n                return [result, current, lastDeletionIndex + 2];\n            }\n\n            result.push(current);\n\n            // Keep the `lastDeletionIndex` if there are lines of deletions,\n            // otherwise update it to the new deletion line\n            const newLastDeletionIndex = isDelete(current) ? (isDelete(last) ? lastDeletionIndex : i) : i;\n\n            return [result, current, newLastDeletionIndex];\n        },\n        [[], null, -1]\n    );\n    return result;\n}\n\nfunction mapHunk(hunk: Hunk, options: ParseOptions) {\n    const changes = options.nearbySequences === 'zip' ? zipChanges(hunk.changes) : hunk.changes;\n\n    return {\n        ...hunk,\n        isPlain: false,\n        changes: changes,\n    };\n}\n\nfunction mapFile(file: File, options: ParseOptions) {\n    const hunks = file.hunks.map(hunk => mapHunk(hunk, options));\n\n    return {...file, hunks};\n}\n\nfunction normalizeDiffText(text: string) {\n    // Git diff header:\n    //\n    // diff --git a/test/fixture/test/ci.go b/test/fixture/test/ci.go\n    // index 6829b8a2..4c565f1b 100644\n    // --- a/test/fixture/test/ci.go\n    // +++ b/test/fixture/test/ci.go\n    if (text.startsWith('diff --git')) {\n        return text;\n    }\n\n    // Unidiff header:\n    //\n    // --- /test/fixture/test/ci.go 2002-02-21 23:30:39.942229878 -0800\n    // +++ /test/fixture/test/ci.go 2002-02-21 23:30:50.442260588 -0800\n    const indexOfFirstLineBreak = text.indexOf('\\n');\n    const indexOfSecondLineBreak = text.indexOf('\\n', indexOfFirstLineBreak + 1);\n    const firstLine = text.slice(0, indexOfFirstLineBreak);\n    const secondLine = text.slice(indexOfFirstLineBreak + 1, indexOfSecondLineBreak);\n    const oldPath = firstLine.split(' ').slice(1, -3).join(' ');\n    const newPath = secondLine.split(' ').slice(1, -3).join(' ');\n    const segments = [\n        `diff --git a/${oldPath} b/${newPath}`,\n        'index 1111111..2222222 100644',\n        `--- a/${oldPath}`,\n        `+++ b/${newPath}`,\n        text.slice(indexOfSecondLineBreak + 1),\n    ];\n\n    return segments.join('\\n');\n}\n\nexport function parseDiff(text: string, options: ParseOptions = {}): File[] {\n    const diffText = normalizeDiffText(text.trimStart());\n    const files = parser.parse(diffText);\n\n    return files.map(file => mapFile(file, options));\n}\n", "import {Side} from '../../interface';\n\nexport function first<T>(array: T[]) {\n    return array[0];\n}\n\nexport function last<T>(array: T[]) {\n    return array[array.length - 1];\n}\n\nexport function sideToProperty(side: Side) {\n    return [`${side}Start`, `${side}Lines`] as const;\n}\n", "import {Side} from '../../interface';\nimport {ChangeData, HunkData, isDelete, isInsert, isNormal} from '../parse';\nimport {first, last, sideToProperty} from './util';\n\ntype ComputeLine = (change: ChangeData) => number;\n\nexport function computeLineNumberFactory(side: Side): ComputeLine {\n    if (side === 'old') {\n        return change => {\n            if (isInsert(change)) {\n                return -1;\n            }\n\n            return isNormal(change) ? change.oldLineNumber : change.lineNumber;\n        };\n    }\n\n    return change => {\n        if (isDelete(change)) {\n            return -1;\n        }\n\n        return isNormal(change) ? change.newLineNumber : change.lineNumber;\n    };\n}\n\ntype IsInHunk = (hunk: HunkData, lineNumber: number) => boolean;\n\ntype StartProperty = 'oldStart' | 'newStart';\n\ntype LinesProperty = 'oldLines' | 'newLines';\n\nexport function isInHunkFactory(startProperty: StartProperty, linesProperty: LinesProperty): IsInHunk {\n    return (hunk, lineNumber) => {\n        const start = hunk[startProperty];\n        const end = start + hunk[linesProperty];\n\n        return lineNumber >= start && lineNumber < end;\n    };\n}\n\ntype IsBetweenHunks = (previousHunk: HunkData, nextHunk: HunkData, lineNumber: number) => boolean;\n\nexport function isBetweenHunksFactory(startProperty: StartProperty, linesProperty: LinesProperty): IsBetweenHunks {\n    return (previousHunk, nextHunk, lineNumber) => {\n        const start = previousHunk[startProperty] + previousHunk[linesProperty];\n        const end = nextHunk[startProperty];\n\n        return lineNumber >= start && lineNumber < end;\n    };\n}\n\ntype FindContainerHunk = (hunks: HunkData[], lineNumber: number) => HunkData | undefined;\n\nfunction findContainerHunkFactory(side: Side): FindContainerHunk {\n    const [startProperty, linesProperty] = sideToProperty(side);\n    const isInHunk = isInHunkFactory(startProperty, linesProperty);\n\n    return (hunks, lineNumber) => hunks.find(hunk => isInHunk(hunk, lineNumber));\n}\n\ntype FindChangeByLineNumber = (hunks: HunkData[], lineNumber: number) => ChangeData | undefined;\n\nexport function findChangeByLineNumberFactory(side: Side): FindChangeByLineNumber {\n    const computeLineNumber = computeLineNumberFactory(side);\n    const findContainerHunk = findContainerHunkFactory(side);\n\n    return (hunks, lineNumber): ChangeData | undefined => {\n        const containerHunk = findContainerHunk(hunks, lineNumber);\n\n        if (!containerHunk) {\n            return undefined;\n        }\n\n        return containerHunk.changes.find(change => computeLineNumber(change) === lineNumber);\n    };\n}\n\ntype GetCorrespondingLineNumber = (hunks: HunkData[], lineNumber: number) => number;\n\nexport function getCorrespondingLineNumberFactory(baseSide: Side): GetCorrespondingLineNumber {\n    const anotherSide = baseSide === 'old' ? 'new' : 'old';\n    const [baseStart, baseLines] = sideToProperty(baseSide);\n    const [correspondingStart, correspondingLines] = sideToProperty(anotherSide);\n    const baseLineNumber = computeLineNumberFactory(baseSide);\n    const correspondingLineNumber = computeLineNumberFactory(anotherSide);\n    const isInHunk = isInHunkFactory(baseStart, baseLines);\n    const isBetweenHunks = isBetweenHunksFactory(baseStart, baseLines);\n\n    /* eslint-disable complexity */\n    return (hunks, lineNumber) => {\n        const firstHunk = first(hunks);\n\n        // Before first hunk\n        if (lineNumber < firstHunk[baseStart]) {\n            const spanFromStart = firstHunk[baseStart] - lineNumber;\n            return firstHunk[correspondingStart] - spanFromStart;\n        }\n\n        // After last hunk, this can be done in `for` loop, just a quick return path\n        const lastHunk = last(hunks);\n        if (lastHunk[baseStart] + lastHunk[baseLines] <= lineNumber) {\n            const spanFromEnd = lineNumber - lastHunk[baseStart] - lastHunk[baseLines];\n            return lastHunk[correspondingStart] + lastHunk[correspondingLines] + spanFromEnd;\n        }\n\n        for (let i = 0; i < hunks.length; i++) {\n            const currentHunk = hunks[i];\n            const nextHunk = hunks[i + 1];\n\n            // Within current hunk\n            if (isInHunk(currentHunk, lineNumber)) {\n                const changeIndex = currentHunk.changes.findIndex(change => baseLineNumber(change) === lineNumber);\n                const change = currentHunk.changes[changeIndex];\n\n                if (isNormal(change)) {\n                    return correspondingLineNumber(change);\n                }\n\n                // For changes of type \"insert\" and \"delete\", the sibling change can be the corresponding one,\n                // or they can have no corresponding change\n                //\n                // Git diff always put delete change before insert change\n                //\n                // Note that `nearbySequences: \"zip\"` option can affect this function\n                const possibleCorrespondingChangeIndex = isDelete(change) ? changeIndex + 1 : changeIndex - 1;\n                const possibleCorrespondingChange = currentHunk.changes[possibleCorrespondingChangeIndex];\n\n                if (!possibleCorrespondingChange) {\n                    return -1;\n                }\n\n                const negativeChangeType = isInsert(change) ? 'delete' : 'insert';\n\n                return possibleCorrespondingChange.type === negativeChangeType\n                    ? correspondingLineNumber(possibleCorrespondingChange)\n                    : -1;\n            }\n\n            // Between 2 hunks\n            if (isBetweenHunks(currentHunk, nextHunk, lineNumber)) {\n                const spanFromEnd = lineNumber - currentHunk[baseStart] - currentHunk[baseLines];\n                return currentHunk[correspondingStart] + currentHunk[correspondingLines] + spanFromEnd;\n            }\n        }\n\n        /* istanbul ignore next Should not arrive here */\n        throw new Error(`Unexpected line position ${lineNumber}`);\n    };\n    /* eslint-enable complexity */\n}\n", "/**\n * The base implementation of `_.findIndex` and `_.findLastIndex` without\n * support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} predicate The function invoked per iteration.\n * @param {number} fromIndex The index to search from.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\n  var length = array.length,\n      index = fromIndex + (fromRight ? 1 : -1);\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = baseFindIndex;\n", "/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\nmodule.exports = listCacheClear;\n", "/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\nmodule.exports = eq;\n", "var eq = require('./eq');\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = assocIndexOf;\n", "var assocIndexOf = require('./_assocIndexOf');\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\nmodule.exports = listCacheDelete;\n", "var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\nmodule.exports = listCacheGet;\n", "var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\nmodule.exports = listCacheHas;\n", "var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\nmodule.exports = listCacheSet;\n", "var listCacheClear = require('./_listCacheClear'),\n    listCacheDelete = require('./_listCacheDelete'),\n    listCacheGet = require('./_listCacheGet'),\n    listCacheHas = require('./_listCacheHas'),\n    listCacheSet = require('./_listCacheSet');\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\nmodule.exports = ListCache;\n", "var ListCache = require('./_ListCache');\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\nmodule.exports = stackClear;\n", "/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\nmodule.exports = stackDelete;\n", "/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\nmodule.exports = stackGet;\n", "/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\nmodule.exports = stackHas;\n", "/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n", "var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n", "var root = require('./_root');\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n", "var Symbol = require('./_Symbol');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n", "/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n", "var Symbol = require('./_Symbol'),\n    getRawTag = require('./_getRawTag'),\n    objectToString = require('./_objectToString');\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n", "/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n", "var baseGetTag = require('./_baseGetTag'),\n    isObject = require('./isObject');\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nmodule.exports = isFunction;\n", "var root = require('./_root');\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\nmodule.exports = coreJsData;\n", "var coreJsData = require('./_coreJsData');\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\nmodule.exports = isMasked;\n", "/** Used for built-in method references. */\nvar funcProto = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nmodule.exports = toSource;\n", "var isFunction = require('./isFunction'),\n    isMasked = require('./_isMasked'),\n    isObject = require('./isObject'),\n    toSource = require('./_toSource');\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\nmodule.exports = baseIsNative;\n", "/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nmodule.exports = getValue;\n", "var baseIsNative = require('./_baseIsNative'),\n    getValue = require('./_getValue');\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\nmodule.exports = getNative;\n", "var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map');\n\nmodule.exports = Map;\n", "var getNative = require('./_getNative');\n\n/* Built-in method references that are verified to be native. */\nvar nativeCreate = getNative(Object, 'create');\n\nmodule.exports = nativeCreate;\n", "var nativeCreate = require('./_nativeCreate');\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\nmodule.exports = hashClear;\n", "/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = hashDelete;\n", "var nativeCreate = require('./_nativeCreate');\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\nmodule.exports = hashGet;\n", "var nativeCreate = require('./_nativeCreate');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\nmodule.exports = hashHas;\n", "var nativeCreate = require('./_nativeCreate');\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\nmodule.exports = hashSet;\n", "var hashClear = require('./_hashClear'),\n    hashDelete = require('./_hashDelete'),\n    hashGet = require('./_hashGet'),\n    hashHas = require('./_hashHas'),\n    hashSet = require('./_hashSet');\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\nmodule.exports = Hash;\n", "var Hash = require('./_Hash'),\n    ListCache = require('./_ListCache'),\n    Map = require('./_Map');\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\nmodule.exports = mapCacheClear;\n", "/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\nmodule.exports = isKeyable;\n", "var isKeyable = require('./_isKeyable');\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\nmodule.exports = getMapData;\n", "var getMapData = require('./_getMapData');\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = mapCacheDelete;\n", "var getMapData = require('./_getMapData');\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\nmodule.exports = mapCacheGet;\n", "var getMapData = require('./_getMapData');\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\nmodule.exports = mapCacheHas;\n", "var getMapData = require('./_getMapData');\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\nmodule.exports = mapCacheSet;\n", "var mapCacheClear = require('./_mapCacheClear'),\n    mapCacheDelete = require('./_mapCacheDelete'),\n    mapCacheGet = require('./_mapCacheGet'),\n    mapCacheHas = require('./_mapCacheHas'),\n    mapCacheSet = require('./_mapCacheSet');\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\nmodule.exports = MapCache;\n", "var ListCache = require('./_ListCache'),\n    Map = require('./_Map'),\n    MapCache = require('./_MapCache');\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\nmodule.exports = stackSet;\n", "var ListCache = require('./_ListCache'),\n    stackClear = require('./_stackClear'),\n    stackDelete = require('./_stackDelete'),\n    stackGet = require('./_stackGet'),\n    stackHas = require('./_stackHas'),\n    stackSet = require('./_stackSet');\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\nmodule.exports = Stack;\n", "/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\nmodule.exports = setCacheAdd;\n", "/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\nmodule.exports = setCacheHas;\n", "var MapCache = require('./_MapCache'),\n    setCacheAdd = require('./_setCacheAdd'),\n    setCacheHas = require('./_setCacheHas');\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\nmodule.exports = SetCache;\n", "/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nmodule.exports = arraySome;\n", "/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\nmodule.exports = cacheHas;\n", "var SetCache = require('./_SetCache'),\n    arraySome = require('./_arraySome'),\n    cacheHas = require('./_cacheHas');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Check that cyclic values are equal.\n  var arrStacked = stack.get(array);\n  var othStacked = stack.get(other);\n  if (arrStacked && othStacked) {\n    return arrStacked == other && othStacked == array;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!cacheHas(seen, othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\nmodule.exports = equalArrays;\n", "var root = require('./_root');\n\n/** Built-in value references. */\nvar Uint8Array = root.Uint8Array;\n\nmodule.exports = Uint8Array;\n", "/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\nmodule.exports = mapToArray;\n", "/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\nmodule.exports = setToArray;\n", "var Symbol = require('./_Symbol'),\n    Uint8Array = require('./_Uint8Array'),\n    eq = require('./eq'),\n    equalArrays = require('./_equalArrays'),\n    mapToArray = require('./_mapToArray'),\n    setToArray = require('./_setToArray');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]';\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\nmodule.exports = equalByTag;\n", "/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\nmodule.exports = arrayPush;\n", "/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nmodule.exports = isArray;\n", "var arrayPush = require('./_arrayPush'),\n    isArray = require('./isArray');\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\nmodule.exports = baseGetAllKeys;\n", "/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayFilter;\n", "/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\nmodule.exports = stubArray;\n", "var arrayFilter = require('./_arrayFilter'),\n    stubArray = require('./stubArray');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\nmodule.exports = getSymbols;\n", "/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\nmodule.exports = baseTimes;\n", "/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n", "var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\nmodule.exports = baseIsArguments;\n", "var baseIsArguments = require('./_baseIsArguments'),\n    isObjectLike = require('./isObjectLike');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\nmodule.exports = isArguments;\n", "/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = stubFalse;\n", "var root = require('./_root'),\n    stubFalse = require('./stubFalse');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\nmodule.exports = isBuffer;\n", "/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\nmodule.exports = isIndex;\n", "/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\nmodule.exports = isLength;\n", "var baseGetTag = require('./_baseGetTag'),\n    isLength = require('./isLength'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\nmodule.exports = baseIsTypedArray;\n", "/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\nmodule.exports = baseUnary;\n", "var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    // Use `util.types` for Node.js 10+.\n    var types = freeModule && freeModule.require && freeModule.require('util').types;\n\n    if (types) {\n      return types;\n    }\n\n    // Legacy `process.binding('util')` for Node.js < 10.\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\nmodule.exports = nodeUtil;\n", "var baseIsTypedArray = require('./_baseIsTypedArray'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\nmodule.exports = isTypedArray;\n", "var baseTimes = require('./_baseTimes'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isIndex = require('./_isIndex'),\n    isTypedArray = require('./isTypedArray');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayLikeKeys;\n", "/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\nmodule.exports = isPrototype;\n", "/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\nmodule.exports = overArg;\n", "var overArg = require('./_overArg');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = overArg(Object.keys, Object);\n\nmodule.exports = nativeKeys;\n", "var isPrototype = require('./_isPrototype'),\n    nativeKeys = require('./_nativeKeys');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeys;\n", "var isFunction = require('./isFunction'),\n    isLength = require('./isLength');\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\nmodule.exports = isArrayLike;\n", "var arrayLikeKeys = require('./_arrayLikeKeys'),\n    baseKeys = require('./_baseKeys'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\nmodule.exports = keys;\n", "var baseGetAllKeys = require('./_baseGetAllKeys'),\n    getSymbols = require('./_getSymbols'),\n    keys = require('./keys');\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\nmodule.exports = getAllKeys;\n", "var getAllKeys = require('./_getAllKeys');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1;\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Check that cyclic values are equal.\n  var objStacked = stack.get(object);\n  var othStacked = stack.get(other);\n  if (objStacked && othStacked) {\n    return objStacked == other && othStacked == object;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\nmodule.exports = equalObjects;\n", "var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView');\n\nmodule.exports = DataView;\n", "var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Promise = getNative(root, 'Promise');\n\nmodule.exports = Promise;\n", "var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Set = getNative(root, 'Set');\n\nmodule.exports = Set;\n", "var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar WeakMap = getNative(root, 'WeakMap');\n\nmodule.exports = WeakMap;\n", "var DataView = require('./_DataView'),\n    Map = require('./_Map'),\n    Promise = require('./_Promise'),\n    Set = require('./_Set'),\n    WeakMap = require('./_WeakMap'),\n    baseGetTag = require('./_baseGetTag'),\n    toSource = require('./_toSource');\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    setTag = '[object Set]',\n    weakMapTag = '[object WeakMap]';\n\nvar dataViewTag = '[object DataView]';\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\nmodule.exports = getTag;\n", "var Stack = require('./_Stack'),\n    equalArrays = require('./_equalArrays'),\n    equalByTag = require('./_equalByTag'),\n    equalObjects = require('./_equalObjects'),\n    getTag = require('./_getTag'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isTypedArray = require('./isTypedArray');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = objIsArr ? arrayTag : getTag(object),\n      othTag = othIsArr ? arrayTag : getTag(other);\n\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer(object)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\nmodule.exports = baseIsEqualDeep;\n", "var baseIsEqualDeep = require('./_baseIsEqualDeep'),\n    isObjectLike = require('./isObjectLike');\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\nmodule.exports = baseIsEqual;\n", "var Stack = require('./_Stack'),\n    baseIsEqual = require('./_baseIsEqual');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * The base implementation of `_.isMatch` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property values to match.\n * @param {Array} matchData The property names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */\nfunction baseIsMatch(object, source, matchData, customizer) {\n  var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer;\n\n  if (object == null) {\n    return !length;\n  }\n  object = Object(object);\n  while (index--) {\n    var data = matchData[index];\n    if ((noCustomizer && data[2])\n          ? data[1] !== object[data[0]]\n          : !(data[0] in object)\n        ) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0],\n        objValue = object[key],\n        srcValue = data[1];\n\n    if (noCustomizer && data[2]) {\n      if (objValue === undefined && !(key in object)) {\n        return false;\n      }\n    } else {\n      var stack = new Stack;\n      if (customizer) {\n        var result = customizer(objValue, srcValue, key, object, source, stack);\n      }\n      if (!(result === undefined\n            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n            : result\n          )) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nmodule.exports = baseIsMatch;\n", "var isObject = require('./isObject');\n\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */\nfunction isStrictComparable(value) {\n  return value === value && !isObject(value);\n}\n\nmodule.exports = isStrictComparable;\n", "var isStrictComparable = require('./_isStrictComparable'),\n    keys = require('./keys');\n\n/**\n * Gets the property names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */\nfunction getMatchData(object) {\n  var result = keys(object),\n      length = result.length;\n\n  while (length--) {\n    var key = result[length],\n        value = object[key];\n\n    result[length] = [key, value, isStrictComparable(value)];\n  }\n  return result;\n}\n\nmodule.exports = getMatchData;\n", "/**\n * A specialized version of `matchesProperty` for source values suitable\n * for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction matchesStrictComparable(key, srcValue) {\n  return function(object) {\n    if (object == null) {\n      return false;\n    }\n    return object[key] === srcValue &&\n      (srcValue !== undefined || (key in Object(object)));\n  };\n}\n\nmodule.exports = matchesStrictComparable;\n", "var baseIsMatch = require('./_baseIsMatch'),\n    getMatchData = require('./_getMatchData'),\n    matchesStrictComparable = require('./_matchesStrictComparable');\n\n/**\n * The base implementation of `_.matches` which doesn't clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatches(source) {\n  var matchData = getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n  }\n  return function(object) {\n    return object === source || baseIsMatch(object, source, matchData);\n  };\n}\n\nmodule.exports = baseMatches;\n", "var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nmodule.exports = isSymbol;\n", "var isArray = require('./isArray'),\n    isSymbol = require('./isSymbol');\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/;\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\nmodule.exports = isKey;\n", "var MapCache = require('./_MapCache');\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\nmodule.exports = memoize;\n", "var memoize = require('./memoize');\n\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n  var result = memoize(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n\n  var cache = result.cache;\n  return result;\n}\n\nmodule.exports = memoizeCapped;\n", "var memoizeCapped = require('./_memoizeCapped');\n\n/** Used to match property names within property paths. */\nvar rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoizeCapped(function(string) {\n  var result = [];\n  if (string.charCodeAt(0) === 46 /* . */) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, subString) {\n    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\nmodule.exports = stringToPath;\n", "/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\nmodule.exports = arrayMap;\n", "var Symbol = require('./_Symbol'),\n    arrayMap = require('./_arrayMap'),\n    isArray = require('./isArray'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = baseToString;\n", "var baseToString = require('./_baseToString');\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\nmodule.exports = toString;\n", "var isArray = require('./isArray'),\n    isKey = require('./_isKey'),\n    stringToPath = require('./_stringToPath'),\n    toString = require('./toString');\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value, object) {\n  if (isArray(value)) {\n    return value;\n  }\n  return isKey(value, object) ? [value] : stringToPath(toString(value));\n}\n\nmodule.exports = castPath;\n", "var isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = toKey;\n", "var castPath = require('./_castPath'),\n    toKey = require('./_toKey');\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = castPath(path, object);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\nmodule.exports = baseGet;\n", "var baseGet = require('./_baseGet');\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nmodule.exports = get;\n", "/**\n * The base implementation of `_.hasIn` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHasIn(object, key) {\n  return object != null && key in Object(object);\n}\n\nmodule.exports = baseHasIn;\n", "var castPath = require('./_castPath'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isIndex = require('./_isIndex'),\n    isLength = require('./isLength'),\n    toKey = require('./_toKey');\n\n/**\n * Checks if `path` exists on `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @param {Function} hasFunc The function to check properties.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n */\nfunction hasPath(object, path, hasFunc) {\n  path = castPath(path, object);\n\n  var index = -1,\n      length = path.length,\n      result = false;\n\n  while (++index < length) {\n    var key = toKey(path[index]);\n    if (!(result = object != null && hasFunc(object, key))) {\n      break;\n    }\n    object = object[key];\n  }\n  if (result || ++index != length) {\n    return result;\n  }\n  length = object == null ? 0 : object.length;\n  return !!length && isLength(length) && isIndex(key, length) &&\n    (isArray(object) || isArguments(object));\n}\n\nmodule.exports = hasPath;\n", "var baseHasIn = require('./_baseHasIn'),\n    hasPath = require('./_hasPath');\n\n/**\n * Checks if `path` is a direct or inherited property of `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.hasIn(object, 'a');\n * // => true\n *\n * _.hasIn(object, 'a.b');\n * // => true\n *\n * _.hasIn(object, ['a', 'b']);\n * // => true\n *\n * _.hasIn(object, 'b');\n * // => false\n */\nfunction hasIn(object, path) {\n  return object != null && hasPath(object, path, baseHasIn);\n}\n\nmodule.exports = hasIn;\n", "var baseIsEqual = require('./_baseIsEqual'),\n    get = require('./get'),\n    hasIn = require('./hasIn'),\n    isKey = require('./_isKey'),\n    isStrictComparable = require('./_isStrictComparable'),\n    matchesStrictComparable = require('./_matchesStrictComparable'),\n    toKey = require('./_toKey');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatchesProperty(path, srcValue) {\n  if (isKey(path) && isStrictComparable(srcValue)) {\n    return matchesStrictComparable(toKey(path), srcValue);\n  }\n  return function(object) {\n    var objValue = get(object, path);\n    return (objValue === undefined && objValue === srcValue)\n      ? hasIn(object, path)\n      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n  };\n}\n\nmodule.exports = baseMatchesProperty;\n", "/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\nmodule.exports = identity;\n", "/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\nmodule.exports = baseProperty;\n", "var baseGet = require('./_baseGet');\n\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyDeep(path) {\n  return function(object) {\n    return baseGet(object, path);\n  };\n}\n\nmodule.exports = basePropertyDeep;\n", "var baseProperty = require('./_baseProperty'),\n    basePropertyDeep = require('./_basePropertyDeep'),\n    isKey = require('./_isKey'),\n    toKey = require('./_toKey');\n\n/**\n * Creates a function that returns the value at `path` of a given object.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': 2 } },\n *   { 'a': { 'b': 1 } }\n * ];\n *\n * _.map(objects, _.property('a.b'));\n * // => [2, 1]\n *\n * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n * // => [1, 2]\n */\nfunction property(path) {\n  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n}\n\nmodule.exports = property;\n", "var baseMatches = require('./_baseMatches'),\n    baseMatchesProperty = require('./_baseMatchesProperty'),\n    identity = require('./identity'),\n    isArray = require('./isArray'),\n    property = require('./property');\n\n/**\n * The base implementation of `_.iteratee`.\n *\n * @private\n * @param {*} [value=_.identity] The value to convert to an iteratee.\n * @returns {Function} Returns the iteratee.\n */\nfunction baseIteratee(value) {\n  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n  if (typeof value == 'function') {\n    return value;\n  }\n  if (value == null) {\n    return identity;\n  }\n  if (typeof value == 'object') {\n    return isArray(value)\n      ? baseMatchesProperty(value[0], value[1])\n      : baseMatches(value);\n  }\n  return property(value);\n}\n\nmodule.exports = baseIteratee;\n", "/** Used to match a single whitespace character. */\nvar reWhitespace = /\\s/;\n\n/**\n * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n * character of `string`.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {number} Returns the index of the last non-whitespace character.\n */\nfunction trimmedEndIndex(string) {\n  var index = string.length;\n\n  while (index-- && reWhitespace.test(string.charAt(index))) {}\n  return index;\n}\n\nmodule.exports = trimmedEndIndex;\n", "var trimmedEndIndex = require('./_trimmedEndIndex');\n\n/** Used to match leading whitespace. */\nvar reTrimStart = /^\\s+/;\n\n/**\n * The base implementation of `_.trim`.\n *\n * @private\n * @param {string} string The string to trim.\n * @returns {string} Returns the trimmed string.\n */\nfunction baseTrim(string) {\n  return string\n    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')\n    : string;\n}\n\nmodule.exports = baseTrim;\n", "var baseTrim = require('./_baseTrim'),\n    isObject = require('./isObject'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = baseTrim(value);\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = toNumber;\n", "var toNumber = require('./toNumber');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_INTEGER = 1.7976931348623157e+308;\n\n/**\n * Converts `value` to a finite number.\n *\n * @static\n * @memberOf _\n * @since 4.12.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted number.\n * @example\n *\n * _.toFinite(3.2);\n * // => 3.2\n *\n * _.toFinite(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toFinite(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toFinite('3.2');\n * // => 3.2\n */\nfunction toFinite(value) {\n  if (!value) {\n    return value === 0 ? value : 0;\n  }\n  value = toNumber(value);\n  if (value === INFINITY || value === -INFINITY) {\n    var sign = (value < 0 ? -1 : 1);\n    return sign * MAX_INTEGER;\n  }\n  return value === value ? value : 0;\n}\n\nmodule.exports = toFinite;\n", "var toFinite = require('./toFinite');\n\n/**\n * Converts `value` to an integer.\n *\n * **Note:** This method is loosely based on\n * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted integer.\n * @example\n *\n * _.toInteger(3.2);\n * // => 3\n *\n * _.toInteger(Number.MIN_VALUE);\n * // => 0\n *\n * _.toInteger(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toInteger('3.2');\n * // => 3\n */\nfunction toInteger(value) {\n  var result = toFinite(value),\n      remainder = result % 1;\n\n  return result === result ? (remainder ? result - remainder : result) : 0;\n}\n\nmodule.exports = toInteger;\n", "var baseFindIndex = require('./_baseFindIndex'),\n    baseIteratee = require('./_baseIteratee'),\n    toInteger = require('./toInteger');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * This method is like `_.findIndex` except that it iterates over elements\n * of `collection` from right to left.\n *\n * @static\n * @memberOf _\n * @since 2.0.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param {number} [fromIndex=array.length-1] The index to search from.\n * @returns {number} Returns the index of the found element, else `-1`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'active': true },\n *   { 'user': 'fred',    'active': false },\n *   { 'user': 'pebbles', 'active': false }\n * ];\n *\n * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });\n * // => 2\n *\n * // The `_.matches` iteratee shorthand.\n * _.findLastIndex(users, { 'user': 'barney', 'active': true });\n * // => 0\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.findLastIndex(users, ['active', false]);\n * // => 2\n *\n * // The `_.property` iteratee shorthand.\n * _.findLastIndex(users, 'active');\n * // => 0\n */\nfunction findLastIndex(array, predicate, fromIndex) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return -1;\n  }\n  var index = length - 1;\n  if (fromIndex !== undefined) {\n    index = toInteger(fromIndex);\n    index = fromIndex < 0\n      ? nativeMax(length + index, 0)\n      : nativeMin(index, length - 1);\n  }\n  return baseFindIndex(array, baseIteratee(predicate, 3), index, true);\n}\n\nmodule.exports = findLastIndex;\n", "import {findLastIndex} from 'lodash';\nimport {ChangeData, HunkData, isDelete, isInsert, isNormal} from '../parse';\nimport {computeLineNumberFactory} from './factory';\nimport {last} from './util';\n\nconst computeOldLineNumber = computeLineNumberFactory('old');\n\nconst computeNewLineNumber = computeLineNumberFactory('new');\n\nfunction getOldRangeFromHunk({oldStart, oldLines}: HunkData) {\n    return [oldStart, oldStart + oldLines - 1];\n}\n\ninterface HunkMayBePlain extends HunkData {\n    isPlain?: boolean;\n}\n\nfunction createHunkFromChanges(changes: ChangeData[]): HunkMayBePlain | null {\n    if (!changes.length) {\n        return null;\n    }\n\n    const initial = {\n        isPlain: true,\n        content: '',\n        oldStart: -1,\n        oldLines: 0,\n        newStart: -1,\n        newLines: 0,\n    };\n    /* eslint-disable no-param-reassign */\n    const hunk = changes.reduce(\n        (hunk, change) => {\n            if (!isNormal(change)) {\n                hunk.isPlain = false;\n            }\n\n            if (!isInsert(change)) {\n                hunk.oldLines = hunk.oldLines + 1;\n\n                if (hunk.oldStart === -1) {\n                    hunk.oldStart = computeOldLineNumber(change);\n                }\n            }\n\n            if (!isDelete(change)) {\n                hunk.newLines = hunk.newLines + 1;\n\n                if (hunk.newStart === -1) {\n                    hunk.newStart = computeNewLineNumber(change);\n                }\n            }\n\n            return hunk;\n        },\n        initial\n    );\n    /* eslint-enable no-param-reassign */\n    const {oldStart, oldLines, newStart, newLines} = hunk;\n\n    return {\n        ...hunk,\n        content: `@@ -${oldStart},${oldLines} +${newStart},${newLines}`,\n        changes: changes,\n    };\n}\n\nexport function textLinesToHunk(lines: string[], oldStartLine: number, newStartLine: number): HunkData | null {\n    const lineToChange = (line: string, i: number): ChangeData => {\n        return {\n            type: 'normal',\n            isNormal: true,\n            oldLineNumber: oldStartLine + i,\n            newLineNumber: newStartLine + i,\n            content: '' + line,\n        };\n    };\n    const changes = lines.map(lineToChange);\n\n    return createHunkFromChanges(changes);\n}\n\nfunction sliceHunk({changes}: HunkData, oldStartLine: number, oldEndLine?: number): HunkMayBePlain | null {\n    const changeIndex = changes.findIndex(change => computeOldLineNumber(change) >= oldStartLine);\n\n    if (changeIndex === -1) {\n        return null;\n    }\n\n    // It is possible to have some insert changes before `startOldLineNumber`,\n    // since we slice from old line number, these changes can be ommited, so we need to grab them back\n    const startIndex = (() => {\n        if (changeIndex === 0) {\n            return changeIndex;\n        }\n\n        const nearestHeadingNocmalChangeIndex = findLastIndex(changes, change => !isInsert(change), changeIndex - 1);\n        return nearestHeadingNocmalChangeIndex === -1 ? changeIndex : nearestHeadingNocmalChangeIndex + 1;\n    })();\n\n    if (oldEndLine === undefined) {\n        const slicedChanges = changes.slice(startIndex);\n\n        return createHunkFromChanges(slicedChanges);\n    }\n\n    const endIndex = findLastIndex(changes, change => computeOldLineNumber(change) <= oldEndLine);\n    const slicedChanges = changes.slice(startIndex, endIndex === -1 ? undefined : endIndex);\n\n    return createHunkFromChanges(slicedChanges);\n}\n\nfunction mergeHunk(previousHunk: HunkMayBePlain | null, nextHunk: HunkMayBePlain | null): HunkData | null {\n    if (!previousHunk) {\n        return nextHunk;\n    }\n\n    if (!nextHunk) {\n        return previousHunk;\n    }\n\n    const [previousStart, previousEnd] = getOldRangeFromHunk(previousHunk);\n    const [nextStart, nextEnd] = getOldRangeFromHunk(nextHunk);\n\n    // They are just neighboring, simply concat changes and adjust lines count\n    if (previousEnd + 1 === nextStart) {\n        return createHunkFromChanges([...previousHunk.changes, ...nextHunk.changes]);\n    }\n\n    // It is possible that `previousHunk` entirely **contains** `nextHunk`,\n    // and if we are merging a fake hunk with a valid hunk, we need to replace `nextHunk`'s corresponding range\n    if (previousStart <= nextStart && previousEnd >= nextEnd) {\n        if (previousHunk.isPlain && !nextHunk.isPlain) {\n            const head = sliceHunk(previousHunk, previousStart, nextStart);\n            const tail = sliceHunk(previousHunk, nextEnd + 1);\n            return mergeHunk(mergeHunk(head, nextHunk), tail);\n        }\n\n        return previousHunk;\n    }\n\n    // The 2 hunks have some overlapping, we need to slice the fake one in order to preserve non-normal changes\n    if (previousHunk.isPlain) {\n        const head = sliceHunk(previousHunk, previousStart, nextStart);\n        return mergeHunk(head, nextHunk);\n    }\n\n    const tail = sliceHunk(nextHunk, previousEnd + 1);\n    return mergeHunk(previousHunk, tail);\n}\n\nfunction appendOrMergeHunk(hunks: HunkData[], nextHunk: HunkData): HunkData[] {\n    const lastHunk = last(hunks);\n\n    if (!lastHunk) {\n        return [nextHunk];\n    }\n\n    const expectedNextStart = lastHunk.oldStart + lastHunk.oldLines;\n    const actualNextStart = nextHunk.oldStart;\n\n    if (expectedNextStart < actualNextStart) {\n        return hunks.concat(nextHunk);\n    }\n\n    const mergedHunk = mergeHunk(lastHunk, nextHunk);\n\n    return mergedHunk ? [...hunks.slice(0, -1), mergedHunk] : hunks;\n}\n\nexport function insertHunk(hunks: HunkData[], insertion: HunkData): HunkData[] {\n    const insertionOldLineNumber = computeOldLineNumber(insertion.changes[0]);\n    const isLaterThanInsertion = ({changes}: HunkData) => {\n        if (!changes.length) {\n            return false;\n        }\n\n        return computeOldLineNumber(changes[0]) >= insertionOldLineNumber;\n    };\n    const insertPosition = hunks.findIndex(isLaterThanInsertion);\n    const hunksWithInsertion = insertPosition === -1\n        ? hunks.concat(insertion)\n        : [\n            ...hunks.slice(0, insertPosition),\n            insertion,\n            ...hunks.slice(insertPosition),\n        ];\n\n    return hunksWithInsertion.reduce(appendOrMergeHunk, []);\n}\n", "import {ChangeData, isNormal, isInsert} from '../parse';\n\nexport function getChangeKey(change: ChangeData) {\n    if (!change) {\n        throw new Error('change is not provided');\n    }\n\n    if (isNormal(change)) {\n        return `N${change.oldLineNumber}`;\n    }\n\n    const prefix = isInsert(change) ? 'I' : 'D';\n    return `${prefix}${change.lineNumber}`;\n}\n", "import {HunkData, isNormal} from '../parse';\nimport {insertHunk, textLinesToHunk} from './insertHunk';\nimport {\n    computeLineNumberFactory,\n    isInHunkFactory,\n    isBetweenHunksFactory,\n    getCorrespondingLineNumberFactory,\n} from './factory';\nimport {first} from './util';\n\nconst getCorrespondingNewLineNumber = getCorrespondingLineNumberFactory('old');\n\nconst computeOldLineNumber = computeLineNumberFactory('old');\n\nconst isOldLineNumberInHunk = isInHunkFactory('oldStart', 'oldLines');\n\nconst isOldLineNumberBetweenHunks = isBetweenHunksFactory('oldStart', 'oldLines');\n\nfunction findCorrespondingValidHunkIndex(hunks: HunkData[], oldLineNumber: number): number {\n    if (!hunks.length) {\n        return -1;\n    }\n\n    const firstHunk = first(hunks);\n    if (oldLineNumber < firstHunk.oldStart || isOldLineNumberInHunk(firstHunk, oldLineNumber)) {\n        return 0;\n    }\n\n    for (let i = 1; i < hunks.length; i++) {\n        const currentHunk = hunks[i];\n\n        if (isOldLineNumberInHunk(currentHunk, oldLineNumber)) {\n            return i;\n        }\n\n        const previousHunk = hunks[i - 1];\n\n        if (isOldLineNumberBetweenHunks(previousHunk, currentHunk, oldLineNumber)) {\n            return i;\n        }\n    }\n\n    return -1;\n}\n\nfunction findNearestNormalChangeIndex({changes}: HunkData, start: number): number {\n    const index = changes.findIndex(change => computeOldLineNumber(change) === start);\n\n    if (index < 0) {\n        return -1;\n    }\n\n    for (let i = index; i < changes.length; i++) {\n        const change = changes[i];\n\n        if (isNormal(change)) {\n            return i;\n        }\n    }\n\n    return -1;\n}\n\ntype Range = [start: number, end: number];\n\nfunction splitRangeToValidOnes(hunks: HunkData[], start: number, end: number): Range[] {\n    const correspondingHunkIndex = findCorrespondingValidHunkIndex(hunks, start);\n\n    // `start` is after all hunks, we believe all left lines are normal.\n    if (correspondingHunkIndex === -1) {\n        return [[start, end]];\n    }\n\n    const correspondingHunk = hunks[correspondingHunkIndex];\n\n    // If `start` points to a line before this hunk, we collect all heading normal changes\n    if (start < correspondingHunk.oldStart) {\n        const headingChangesCount = correspondingHunk.changes.findIndex(change => !isNormal(change));\n        const validEnd = correspondingHunk.oldStart + Math.max(headingChangesCount, 0);\n\n        if (validEnd >= end) {\n            return [[start, end]];\n        }\n\n        return [\n            [start, validEnd],\n            ...splitRangeToValidOnes(hunks, validEnd + 1, end),\n        ];\n    }\n\n    // Now the `correspondingHunk` must be a hunk containing `start`,\n    // however it is still possible that `start` is not a normal change\n    const {changes} = correspondingHunk;\n    const nearestNormalChangeIndex = findNearestNormalChangeIndex(correspondingHunk, start);\n\n    // If there is no normal changes after `start`, splitting ends up here\n    if (nearestNormalChangeIndex === -1) {\n        return [];\n    }\n\n    const validStartChange = changes[nearestNormalChangeIndex];\n    const validStart = computeOldLineNumber(validStartChange);\n    // Iterate to `end`, if `end` falls out of hunk, we can split it to 2 ranges\n    const adjacentChangesCount = changes.slice(nearestNormalChangeIndex + 1).findIndex(change => !isNormal(change));\n    const validEnd = computeOldLineNumber(validStartChange) + Math.max(adjacentChangesCount, 0);\n\n    if (validEnd >= end) {\n        return [[validStart, end]];\n    }\n\n    return [\n        [validStart, validEnd],\n        ...splitRangeToValidOnes(hunks, validEnd + 1, end),\n    ];\n}\n\nexport type Source = string | string[];\n\nfunction expandCodeByValidRange(hunks: HunkData[], source: Source, [start, end]: Range): HunkData[] {\n    // Note `end` is not inclusive, this is the same as `Array.prototype.slice` method\n    const linesOfCode = typeof source === 'string' ? source.split('\\n') : source;\n    const slicedLines = linesOfCode.slice(Math.max(start, 1) - 1, end - 1);\n\n    if (!slicedLines.length) {\n        return hunks;\n    }\n\n    const slicedHunk = textLinesToHunk(slicedLines, start, getCorrespondingNewLineNumber(hunks, start));\n    return slicedHunk ? insertHunk(hunks, slicedHunk) : hunks;\n}\n\nexport function expandFromRawCode(hunks: HunkData[], source: Source, start: number, end: number): HunkData[] {\n    // It is possible to have some insert or delete changes between `start` and `end`,\n    // in order to be 100% safe, we need to split the range to one or more ranges which contains only normal changes.\n    //\n    // For each `start` line number, we can either:\n    //\n    // 1. Find a change and adjust to a nearest normal one.\n    // 2. Find no corresponding change so it must be a collapsed normal change.\n    //\n    // For both cases we can have a starting normal change, then we iterate over its subsequent changes\n    // (line numbers with no corresponding change is considered a normal one)\n    // until an insert or delete is encountered, this is a **valid range**.\n    //\n    // After one valid range is resolved, discard all line numbers related to delete changes, the next normal change\n    // is the start of next valid range.\n    const validRanges = splitRangeToValidOnes(hunks, start, end);\n\n    return validRanges.reduce((hunks, range) => expandCodeByValidRange(hunks, source, range), hunks);\n}\n\nexport function getCollapsedLinesCountBetween(previousHunk: HunkData | null, nextHunk: HunkData): number {\n    if (!previousHunk) {\n        return nextHunk.oldStart - 1;\n    }\n\n    const previousEnd = previousHunk.oldStart + previousHunk.oldLines;\n    const nextStart = nextHunk.oldStart;\n\n    return nextStart - previousEnd;\n}\n\ntype HunkPredicate = (lines: number, oldStart: number, newStart: number) => boolean;\n\nexport function expandCollapsedBlockBy(hunks: HunkData[], source: Source, predicate: HunkPredicate): HunkData[] {\n    const linesOfCode = typeof source === 'string' ? source.split('\\n') : source;\n    const firstHunk = first(hunks);\n    const initialExpandingBlocks = predicate(firstHunk.oldStart - 1, 1, 1) ? [[1, firstHunk.oldStart]] : [];\n\n    const expandingBlocks = hunks.reduce(\n        (expandingBlocks, currentHunk, index, hunks) => {\n            const nextHunk = hunks[index + 1];\n            const oldStart = currentHunk.oldStart + currentHunk.oldLines;\n            const newStart = currentHunk.newStart + currentHunk.newLines;\n            const lines = nextHunk\n                ? getCollapsedLinesCountBetween(currentHunk, nextHunk)\n                : linesOfCode.length - oldStart + 1;\n            const shouldExpand = predicate(lines, oldStart, newStart);\n\n            if (shouldExpand) {\n                // initialExpandingBlocks is scoped, it is redundant to copy the array\n                expandingBlocks.push([oldStart, oldStart + lines]);\n            }\n            return expandingBlocks;\n        },\n        initialExpandingBlocks\n    );\n\n    return expandingBlocks.reduce((hunks, [start, end]) => expandFromRawCode(hunks, linesOfCode, start, end), hunks);\n}\n", "import {computeLineNumberFactory, findChangeByLineNumberFactory, getCorrespondingLineNumberFactory} from './factory';\n\nexport {insertHunk, textLinesToHunk} from './insertHunk';\nexport {getChangeKey} from './getChangeKey';\nexport {expandCollapsedBlockBy, getCollapsedLinesCountBetween, expandFromRawCode} from './expandCollapsedBlockBy';\n\nexport type {Source} from './expandCollapsedBlockBy';\n\nexport const computeOldLineNumber = computeLineNumberFactory('old');\n\nexport const computeNewLineNumber = computeLineNumberFactory('new');\n\nexport const findChangeByOldLineNumber = findChangeByLineNumberFactory('old');\n\nexport const findChangeByNewLineNumber = findChangeByLineNumberFactory('new');\n\nexport const getCorrespondingOldLineNumber = getCorrespondingLineNumberFactory('new');\n\nexport const getCorrespondingNewLineNumber = getCorrespondingLineNumberFactory('old');\n", "var getNative = require('./_getNative');\n\nvar defineProperty = (function() {\n  try {\n    var func = getNative(Object, 'defineProperty');\n    func({}, '', {});\n    return func;\n  } catch (e) {}\n}());\n\nmodule.exports = defineProperty;\n", "var defineProperty = require('./_defineProperty');\n\n/**\n * The base implementation of `assignValue` and `assignMergeValue` without\n * value checks.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction baseAssignValue(object, key, value) {\n  if (key == '__proto__' && defineProperty) {\n    defineProperty(object, key, {\n      'configurable': true,\n      'enumerable': true,\n      'value': value,\n      'writable': true\n    });\n  } else {\n    object[key] = value;\n  }\n}\n\nmodule.exports = baseAssignValue;\n", "/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\nmodule.exports = createBaseFor;\n", "var createBaseFor = require('./_createBaseFor');\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\nmodule.exports = baseFor;\n", "var baseFor = require('./_baseFor'),\n    keys = require('./keys');\n\n/**\n * The base implementation of `_.forOwn` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return object && baseFor(object, iteratee, keys);\n}\n\nmodule.exports = baseForOwn;\n", "var baseAssignValue = require('./_baseAssignValue'),\n    baseForOwn = require('./_baseForOwn'),\n    baseIteratee = require('./_baseIteratee');\n\n/**\n * Creates an object with the same keys as `object` and values generated\n * by running each own enumerable string keyed property of `object` thru\n * `iteratee`. The iteratee is invoked with three arguments:\n * (value, key, object).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Object\n * @param {Object} object The object to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Object} Returns the new mapped object.\n * @see _.mapKeys\n * @example\n *\n * var users = {\n *   'fred':    { 'user': 'fred',    'age': 40 },\n *   'pebbles': { 'user': 'pebbles', 'age': 1 }\n * };\n *\n * _.mapValues(users, function(o) { return o.age; });\n * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n *\n * // The `_.property` iteratee shorthand.\n * _.mapValues(users, 'age');\n * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n */\nfunction mapValues(object, iteratee) {\n  var result = {};\n  iteratee = baseIteratee(iteratee, 3);\n\n  baseForOwn(object, function(value, key, object) {\n    baseAssignValue(result, key, iteratee(value, key, object));\n  });\n  return result;\n}\n\nmodule.exports = mapValues;\n", "import {HTMLAttributes, memo} from 'react';\nimport classNames from 'classnames';\nimport {TokenNode} from '../tokenize';\nimport {DefaultRenderToken, RenderToken} from '../context';\n\nconst defaultRenderToken: DefaultRenderToken = ({type, value, markType, properties, className, children}, i) => {\n    const renderWithClassName = (className: string) => (\n        <span key={i} className={className}>\n            {value ? value : (children && children.map(defaultRenderToken))}\n        </span>\n    );\n\n\n    switch (type) {\n        case 'text':\n            return value;\n        case 'mark':\n            return renderWithClassName(`diff-code-mark diff-code-mark-${markType}`);\n        case 'edit':\n            return renderWithClassName('diff-code-edit');\n        default: {\n            // properties normally not exist since it is deconstructed in pickRange, remove in next major release\n            const legacyClassName = properties && properties.className;\n            return renderWithClassName(classNames(className || legacyClassName));\n        }\n    }\n};\n\nfunction isEmptyToken(tokens: TokenNode[]) {\n    if (!Array.isArray(tokens)) {\n        return true;\n    }\n\n    if (tokens.length > 1) {\n        return false;\n    }\n\n    if (tokens.length === 1) {\n        const [token] = tokens;\n        return token.type === 'text' && !token.value;\n    }\n\n    return true;\n}\n\nexport interface CodeCellProps extends HTMLAttributes<HTMLTableCellElement> {\n    changeKey: string;\n    text: string;\n    tokens: TokenNode[] | null;\n    renderToken: RenderToken | undefined;\n}\n\nfunction CodeCell(props: CodeCellProps) {\n    const {changeKey, text, tokens, renderToken, ...attributes} = props;\n    const actualRenderToken: DefaultRenderToken = renderToken\n        ? (token, i) => renderToken(token, defaultRenderToken, i)\n        : defaultRenderToken;\n\n    return (\n        <td {...attributes} data-change-key={changeKey}>\n            {\n                tokens\n                    ? (isEmptyToken(tokens) ? ' ' : tokens.map(actualRenderToken))\n                    : (text || ' ')\n            }\n        </td>\n    );\n}\n\nexport default memo(CodeCell);\n", "import {ReactNode} from 'react';\nimport {Side} from '../interface';\nimport {computeOldLineNumber, computeNewLineNumber, ChangeData} from '../utils';\n\nexport function renderDefaultBy(change: ChangeData, side: Side) {\n    return (): ReactNode => {\n        const lineNumber = side === 'old' ? computeOldLineNumber(change) : computeNewLineNumber(change);\n        return lineNumber === -1 ? undefined : lineNumber;\n    };\n}\n\nexport function wrapInAnchorBy(gutterAnchor: boolean, anchorTarget: string | null | undefined) {\n    return (element: ReactNode): ReactNode => {\n        if (!gutterAnchor || !element) {\n            return element;\n        }\n\n        return <a href={anchorTarget ? '#' + anchorTarget : undefined}>{element}</a>;\n    };\n}\n\nexport function composeCallback<E>(own: () => void, custom: ((e: E) => void) | undefined) {\n    if (custom) {\n        return (e: E) => {\n            own();\n            custom(e); // `custom` is already bound with `arg`\n        };\n    }\n\n    return own;\n}\n", "import {memo, useState, useMemo, useCallback} from 'react';\nimport classNames from 'classnames';\nimport {mapValues} from 'lodash';\nimport {ChangeData, getChangeKey} from '../../utils';\nimport {TokenNode} from '../../tokenize';\nimport {Side} from '../../interface';\nimport {ChangeEventArgs, EventMap, GutterOptions, NativeEventMap, RenderGutter} from '../../context';\nimport {ChangeSharedProps} from '../interface';\nimport CodeCell from '../CodeCell';\nimport {composeCallback, renderDefaultBy, wrapInAnchorBy} from '../utils';\n\ninterface UnifiedChangeProps extends ChangeSharedProps {\n    change: ChangeData;\n    tokens: TokenNode[] | null;\n    className: string;\n    selected: boolean;\n}\n\nfunction useBoundCallbacks(callbacks: EventMap, arg: ChangeEventArgs, hoverOn: () => void, hoverOff: () => void) {\n    return useMemo(\n        () => {\n            const output: NativeEventMap = mapValues(callbacks, fn => (e: any) => fn && fn(arg, e));\n            output.onMouseEnter = composeCallback(hoverOn, output.onMouseEnter);\n            output.onMouseLeave = composeCallback(hoverOff, output.onMouseLeave);\n            return output;\n        },\n        [callbacks, hoverOn, hoverOff, arg]\n    );\n}\n\nfunction useBoolean() {\n    const [value, setValue] = useState(false);\n    const on = useCallback(() => setValue(true), []);\n    const off = useCallback(() => setValue(false), []);\n    return [value, on, off] as const;\n}\n\nfunction renderGutterCell(\n    className: string,\n    change: ChangeData,\n    changeKey: string,\n    side: Side,\n    gutterAnchor: boolean,\n    anchorTarget: string | undefined,\n    events: NativeEventMap,\n    inHoverState: boolean,\n    renderGutter: RenderGutter\n) {\n    const gutterOptions: GutterOptions = {\n        change,\n        side,\n        inHoverState,\n        renderDefault: renderDefaultBy(change, side),\n        wrapInAnchor: wrapInAnchorBy(gutterAnchor, anchorTarget),\n    };\n\n    return (\n        <td className={className} {...events} data-change-key={changeKey}>\n            {renderGutter(gutterOptions)}\n        </td>\n    );\n}\n\nfunction UnifiedChange(props: UnifiedChangeProps) {\n    const {\n        change,\n        selected,\n        tokens,\n        className,\n        generateLineClassName,\n        gutterClassName,\n        codeClassName,\n        gutterEvents,\n        codeEvents,\n        hideGutter,\n        gutterAnchor,\n        generateAnchorID,\n        renderToken,\n        renderGutter,\n    } = props;\n    const {type, content} = change;\n    const changeKey = getChangeKey(change);\n\n    const [hover, hoverOn, hoverOff] = useBoolean();\n    const eventArg = useMemo(() => ({change}), [change]);\n    const boundGutterEvents = useBoundCallbacks(gutterEvents, eventArg, hoverOn, hoverOff);\n    const boundCodeEvents = useBoundCallbacks(codeEvents, eventArg, hoverOn, hoverOff);\n\n    const anchorID = generateAnchorID(change);\n    const lineClassName = generateLineClassName({\n        changes: [change],\n        defaultGenerate: () => className,\n    });\n\n    const gutterClassNameValue = classNames(\n        'diff-gutter',\n        `diff-gutter-${type}`,\n        gutterClassName,\n        {'diff-gutter-selected': selected}\n    );\n    const codeClassNameValue = classNames(\n        'diff-code',\n        `diff-code-${type}`,\n        codeClassName,\n        {'diff-code-selected': selected}\n    );\n\n    return (\n        <tr id={anchorID} className={classNames('diff-line', lineClassName)}>\n            {\n                !hideGutter && renderGutterCell(\n                    gutterClassNameValue,\n                    change,\n                    changeKey,\n                    'old',\n                    gutterAnchor,\n                    anchorID,\n                    boundGutterEvents,\n                    hover,\n                    renderGutter\n                )\n            }\n            {\n                !hideGutter && renderGutterCell(\n                    gutterClassNameValue,\n                    change,\n                    changeKey,\n                    'new',\n                    gutterAnchor,\n                    anchorID,\n                    boundGutterEvents,\n                    hover,\n                    renderGutter\n                )\n            }\n            <CodeCell\n                className={codeClassNameValue}\n                changeKey={changeKey}\n                text={content}\n                tokens={tokens}\n                renderToken={renderToken}\n                {...boundCodeEvents}\n            />\n        </tr>\n    );\n}\n\nexport default memo(UnifiedChange);\n", "import {ReactNode} from 'react';\n\nexport interface UnifiedWidgetProps {\n    hideGutter: boolean;\n    element: ReactNode;\n}\n\nexport default function UnifiedWidget({hideGutter, element}: UnifiedWidgetProps) {\n    return (\n        <tr className=\"diff-widget\">\n            <td colSpan={hideGutter ? 1 : 3} className=\"diff-widget-content\">\n                {element}\n            </td>\n        </tr>\n    );\n}\n", "import classNames from 'classnames';\nimport {ReactNode} from 'react';\nimport {getChangeKey, computeOldLineNumber, computeNewLineNumber, ChangeData, isDelete} from '../../utils';\nimport {ActualHunkProps} from '../interface';\nimport UnifiedChange from './UnifiedChange';\nimport UnifiedWidget from './UnifiedWidget';\n\ntype ElementContext = ['change', string, ChangeData] | ['widget', string, ReactNode];\n\nfunction groupElements(changes: ChangeData[], widgets: Record<string, ReactNode>) {\n    return changes.reduce<ElementContext[]>(\n        (elements, change) => {\n            const key = getChangeKey(change);\n\n            elements.push(['change', key, change]);\n\n            const widget = widgets[key];\n\n            if (widget) {\n                elements.push(['widget', key, widget]);\n            }\n\n            return elements;\n        },\n        []\n    );\n}\n\ntype RenderRowProps = Omit<ActualHunkProps, 'hunk' | 'widgets' | 'className'>;\n\nfunction renderRow([type, key, value]: ElementContext, props: RenderRowProps) {\n    const {hideGutter, selectedChanges, tokens, lineClassName, ...changeProps} = props;\n\n    if (type === 'change') {\n        const side = isDelete(value) ? 'old' : 'new';\n        const lineNumber = isDelete(value) ? computeOldLineNumber(value) : computeNewLineNumber(value);\n        const tokensOfLine = tokens ? tokens[side][lineNumber - 1] : null;\n\n        return (\n            <UnifiedChange\n                key={`change${key}`}\n                className={lineClassName}\n                change={value}\n                hideGutter={hideGutter}\n                selected={selectedChanges.includes(key)}\n                tokens={tokensOfLine}\n                {...changeProps}\n            />\n        );\n    }\n    else if (type === 'widget') {\n        return <UnifiedWidget key={`widget${key}`} hideGutter={hideGutter} element={value} />;\n    }\n\n    return null;\n}\n\nexport default function UnifiedHunk(props: ActualHunkProps) {\n    const {hunk, widgets, className, ...childrenProps} = props;\n    const elements = groupElements(hunk.changes, widgets);\n\n    return (\n        <tbody className={classNames('diff-hunk', className)}>\n            {elements.map(element => renderRow(element, childrenProps))}\n        </tbody>\n    );\n}\n", "import {memo, useState, useMemo, useCallback} from 'react';\nimport classNames from 'classnames';\nimport {mapValues} from 'lodash';\nimport {ChangeData, getChangeKey} from '../../utils';\nimport {TokenNode} from '../../tokenize';\nimport {Side} from '../../interface';\nimport {RenderToken, RenderGutter, GutterOptions, EventMap, NativeEventMap} from '../../context';\nimport {ChangeSharedProps} from '../interface';\nimport CodeCell from '../CodeCell';\nimport {composeCallback, renderDefaultBy, wrapInAnchorBy} from '../utils';\n\nconst SIDE_OLD = 0;\nconst SIDE_NEW = 1;\n\ntype SetHover = (side: Side | '') => void;\n\nfunction useCallbackOnSide(side: Side, setHover: SetHover, change: ChangeData | null, customCallbacks: EventMap) {\n    const markHover = useCallback(() => setHover(side), [side, setHover]);\n    const unmarkHover = useCallback(() => setHover(''), [setHover]);\n    // Unlike selectors, hooks do not provide native functionality to customize comparator,\n    // on realizing that this does not reduce amount of renders, only preventing duplicate merge computations,\n    // we decide not to optimize this extremely, leave it recomputed on certain rerenders.\n    const callbacks = useMemo(\n        () => {\n            const callbacks: NativeEventMap = mapValues(customCallbacks, fn => (e: any) => fn && fn({side, change}, e));\n            callbacks.onMouseEnter = composeCallback(markHover, callbacks.onMouseEnter);\n            callbacks.onMouseLeave = composeCallback(unmarkHover, callbacks.onMouseLeave);\n            return callbacks;\n        },\n        [change, customCallbacks, markHover, side, unmarkHover]\n    );\n    return callbacks;\n}\n\ninterface RenderCellArgs {\n    change: ChangeData | null;\n    side: typeof SIDE_OLD | typeof SIDE_NEW;\n    selected: boolean;\n    tokens: TokenNode[] | null;\n    gutterClassName: string;\n    codeClassName: string;\n    gutterEvents: NativeEventMap;\n    codeEvents: NativeEventMap;\n    anchorID: string | null | undefined;\n    gutterAnchor: boolean;\n    gutterAnchorTarget: string | null | undefined;\n    hideGutter: boolean;\n    hover: boolean;\n    renderToken: RenderToken | undefined;\n    renderGutter: RenderGutter;\n}\n\nfunction renderCells(args: RenderCellArgs) {\n    const {\n        change,\n        side,\n        selected,\n        tokens,\n        gutterClassName,\n        codeClassName,\n        gutterEvents,\n        codeEvents,\n        anchorID,\n        gutterAnchor,\n        gutterAnchorTarget,\n        hideGutter,\n        hover,\n        renderToken,\n        renderGutter,\n    } = args;\n\n    if (!change) {\n        const gutterClassNameValue = classNames('diff-gutter', 'diff-gutter-omit', gutterClassName);\n        const codeClassNameValue = classNames('diff-code', 'diff-code-omit', codeClassName);\n\n        return [\n            !hideGutter && <td key=\"gutter\" className={gutterClassNameValue} />,\n            <td key=\"code\" className={codeClassNameValue} />,\n        ];\n    }\n\n    const {type, content} = change;\n    const changeKey = getChangeKey(change);\n    const sideName = side === SIDE_OLD ? 'old' : 'new';\n    const gutterClassNameValue = classNames(\n        'diff-gutter',\n        `diff-gutter-${type}`,\n        {\n            'diff-gutter-selected': selected,\n            ['diff-line-hover-' + sideName]: hover,\n        },\n        gutterClassName\n    );\n    const gutterOptions: GutterOptions = {\n        change,\n        side: sideName,\n        inHoverState: hover,\n        renderDefault: renderDefaultBy(change, sideName),\n        wrapInAnchor: wrapInAnchorBy(gutterAnchor, gutterAnchorTarget),\n    };\n    const gutterProps = {\n        id: anchorID || undefined,\n        className: gutterClassNameValue,\n        children: renderGutter(gutterOptions),\n        ...gutterEvents,\n    };\n    const codeClassNameValue = classNames(\n        'diff-code',\n        `diff-code-${type}`,\n        {\n            'diff-code-selected': selected,\n            ['diff-line-hover-' + sideName]: hover,\n        },\n        codeClassName\n    );\n\n    return [\n        !hideGutter && <td key=\"gutter\" {...gutterProps} data-change-key={changeKey} />,\n        <CodeCell\n            key=\"code\"\n            className={codeClassNameValue}\n            changeKey={changeKey}\n            text={content}\n            tokens={tokens}\n            renderToken={renderToken}\n            {...codeEvents}\n        />,\n    ];\n}\n\ninterface SplitChangeProps extends ChangeSharedProps {\n    className: string;\n    oldChange: ChangeData | null;\n    newChange: ChangeData | null;\n    oldSelected: boolean;\n    newSelected: boolean;\n    oldTokens: TokenNode[] | null;\n    newTokens: TokenNode[] | null;\n    monotonous: boolean;\n}\n\nfunction SplitChange(props: SplitChangeProps) {\n    const {\n        className,\n        oldChange,\n        newChange,\n        oldSelected,\n        newSelected,\n        oldTokens,\n        newTokens,\n        monotonous,\n        gutterClassName,\n        codeClassName,\n        gutterEvents,\n        codeEvents,\n        hideGutter,\n        generateAnchorID,\n        generateLineClassName,\n        gutterAnchor,\n        renderToken,\n        renderGutter,\n    } = props;\n\n    const [hover, setHover] = useState('');\n    const oldGutterEvents = useCallbackOnSide('old', setHover, oldChange, gutterEvents);\n    const newGutterEvents = useCallbackOnSide('new', setHover, newChange, gutterEvents);\n    const oldCodeEvents = useCallbackOnSide('old', setHover, oldChange, codeEvents);\n    const newCodeEvents = useCallbackOnSide('new', setHover, newChange, codeEvents);\n    const oldAnchorID = oldChange && generateAnchorID(oldChange);\n    const newAnchorID = newChange && generateAnchorID(newChange);\n\n    const lineClassName = generateLineClassName({\n        changes: [oldChange!, newChange!],\n        defaultGenerate: () => className,\n    });\n\n    const commons = {\n        monotonous,\n        hideGutter,\n        gutterClassName,\n        codeClassName,\n        gutterEvents,\n        codeEvents,\n        renderToken,\n        renderGutter,\n    };\n    const oldArgs: RenderCellArgs = {\n        ...commons,\n        change: oldChange,\n        side: SIDE_OLD,\n        selected: oldSelected,\n        tokens: oldTokens,\n        gutterEvents: oldGutterEvents,\n        codeEvents: oldCodeEvents,\n        anchorID: oldAnchorID,\n        gutterAnchor: gutterAnchor,\n        gutterAnchorTarget: oldAnchorID,\n        hover: hover === 'old',\n    };\n    const newArgs: RenderCellArgs = {\n        ...commons,\n        change: newChange,\n        side: SIDE_NEW,\n        selected: newSelected,\n        tokens: newTokens,\n        gutterEvents: newGutterEvents,\n        codeEvents: newCodeEvents,\n        anchorID: oldChange === newChange ? null : newAnchorID,\n        gutterAnchor: gutterAnchor,\n        gutterAnchorTarget: oldChange === newChange ? oldAnchorID : newAnchorID,\n        hover: hover === 'new',\n    };\n\n    if (monotonous) {\n        return (\n            <tr className={classNames('diff-line', lineClassName)}>\n                {renderCells(oldChange ? oldArgs : newArgs)}\n            </tr>\n        );\n    }\n\n    const lineTypeClassName = ((oldChange, newChange) => {\n        if (oldChange && !newChange) {\n            return 'diff-line-old-only';\n        }\n\n        if (!oldChange && newChange) {\n            return 'diff-line-new-only';\n        }\n\n        if (oldChange === newChange) {\n            return 'diff-line-normal';\n        }\n\n        return 'diff-line-compare';\n    })(oldChange, newChange);\n\n    return (\n        <tr className={classNames('diff-line', lineTypeClassName, lineClassName)}>\n            {renderCells(oldArgs)}\n            {renderCells(newArgs)}\n        </tr>\n    );\n}\n\nexport default memo(SplitChange);\n", "import {ReactNode} from 'react';\n\nexport interface SplitWidgetProps {\n    hideGutter: boolean;\n    oldElement: ReactNode | null;\n    newElement: ReactNode | null;\n    monotonous: boolean;\n}\n\nexport default function SplitWidget({hideGutter, oldElement, newElement, monotonous}: SplitWidgetProps) {\n    if (monotonous) {\n        return (\n            <tr className=\"diff-widget\">\n                <td colSpan={hideGutter ? 1 : 2} className=\"diff-widget-content\">\n                    {oldElement || newElement}\n                </td>\n            </tr>\n        );\n    }\n\n    if (oldElement === newElement) {\n        return (\n            <tr className=\"diff-widget\">\n                <td colSpan={hideGutter ? 2 : 4} className=\"diff-widget-content\">\n                    {oldElement}\n                </td>\n            </tr>\n        );\n    }\n\n    return (\n        <tr className=\"diff-widget\">\n            <td colSpan={hideGutter ? 1 : 2} className=\"diff-widget-content\">\n                {oldElement}\n            </td>\n            <td colSpan={hideGutter ? 1 : 2} className=\"diff-widget-content\">\n                {newElement}\n            </td>\n        </tr>\n    );\n}\n", "import classNames from 'classnames';\nimport {ReactNode} from 'react';\nimport {\n    getChangeKey,\n    computeOldLineNumber,\n    computeNewLineNumber,\n    ChangeData,\n    isInsert,\n    isDelete,\n    isNormal,\n} from '../../utils';\nimport {ActualHunkProps} from '../interface';\nimport SplitChange from './SplitChange';\nimport SplitWidget from './SplitWidget';\n\ntype ChangeContext = ['change', string, ChangeData | null, ChangeData | null];\n\ntype WidgetContext = ['widget', string, ReactNode | null, ReactNode | null];\n\ntype ElementContext = ChangeContext | WidgetContext;\n\nfunction keyForPair(x: ChangeData | null, y: ChangeData | null) {\n    const keyForX = x ? getChangeKey(x) : '00';\n    const keyForY = y ? getChangeKey(y) : '00';\n    return keyForX + keyForY;\n}\n\nfunction groupElements(changes: ChangeData[], widgets: Record<string, ReactNode>) {\n    const findWidget = (change: ChangeData | null) => {\n        if (!change) {\n            return null;\n        }\n\n        const key = getChangeKey(change);\n        return widgets[key] || null;\n    };\n    const elements: ElementContext[] = [];\n\n    // This could be a very complex reduce call, use `for` loop seems to make it a little more readable\n    for (let i = 0; i < changes.length; i++) {\n        const current = changes[i];\n\n        // A normal change is displayed on both side\n        if (isNormal(current)) {\n            elements.push(['change', keyForPair(current, current), current, current]);\n        }\n        else if (isDelete(current)) {\n            const next = changes[i + 1];\n            // If an insert change is following a elete change, they should be displayed side by side\n            if (next && isInsert(next)) {\n                i = i + 1;\n                elements.push(['change', keyForPair(current, next), current, next]);\n            }\n            else {\n                elements.push(['change', keyForPair(current, null), current, null]);\n            }\n        }\n        else {\n            elements.push(['change', keyForPair(null, current), null, current]);\n        }\n\n        const rowChanges = elements[elements.length - 1] as ChangeContext;\n        const oldWidget = findWidget(rowChanges[2]);\n        const newWidget = findWidget(rowChanges[3]);\n        if (oldWidget || newWidget) {\n            const key = rowChanges[1];\n            elements.push(['widget', key, oldWidget, newWidget]);\n        }\n    }\n\n    return elements;\n}\n\n\ntype RenderRowProps = Omit<ActualHunkProps, 'hunk' | 'widgets' | 'className'>;\n\nfunction renderRow([type, key, oldValue, newValue]: ElementContext, props: RenderRowProps) {\n    const {\n        selectedChanges,\n        monotonous,\n        hideGutter,\n        tokens,\n        lineClassName,\n        ...changeProps\n    } = props;\n\n    if (type === 'change') {\n        const oldSelected = oldValue ? selectedChanges.includes(getChangeKey(oldValue)) : false;\n        const newSelected = newValue ? selectedChanges.includes(getChangeKey(newValue)) : false;\n        const oldTokens = (oldValue && tokens) ? tokens.old[computeOldLineNumber(oldValue) - 1] : null;\n        const newTokens = (newValue && tokens) ? tokens.new[computeNewLineNumber(newValue) - 1] : null;\n\n        return (\n            <SplitChange\n                key={`change${key}`}\n                className={lineClassName}\n                oldChange={oldValue}\n                newChange={newValue}\n                monotonous={monotonous}\n                hideGutter={hideGutter}\n                oldSelected={oldSelected}\n                newSelected={newSelected}\n                oldTokens={oldTokens}\n                newTokens={newTokens}\n                {...changeProps}\n            />\n        );\n    }\n    else if (type === 'widget') {\n        return (\n            <SplitWidget\n                key={`widget${key}`}\n                monotonous={monotonous}\n                hideGutter={hideGutter}\n                oldElement={oldValue}\n                newElement={newValue}\n            />\n        );\n    }\n\n    return null;\n}\n\nexport default function SplitHunk(props: ActualHunkProps) {\n    const {hunk, widgets, className, ...childrenProps} = props;\n    const elements = groupElements(hunk.changes, widgets);\n\n    return (\n        <tbody className={classNames('diff-hunk', className)}>\n            {elements.map(item => renderRow(item, childrenProps))}\n        </tbody>\n    );\n}\n", "import {useDiffSettings} from '../context';\nimport UnifiedHunk from './UnifiedHunk';\nimport SplitHunk from './SplitHunk';\nimport {HunkData} from '../utils';\n\nexport interface HunkProps {\n    hunk: HunkData;\n}\n\nfunction Hunk({hunk}: HunkProps) {\n    const {gutterType, hunkClassName, ...context} = useDiffSettings();\n    const hideGutter = gutterType === 'none';\n    const gutterAnchor = gutterType === 'anchor';\n    const RenderingHunk = context.viewType === 'unified' ? UnifiedHunk : SplitHunk;\n\n    return (\n        <RenderingHunk\n            {...context}\n            hunk={hunk}\n            hideGutter={hideGutter}\n            gutterAnchor={gutterAnchor}\n            className={hunkClassName}\n        />\n    );\n}\n\nexport default Hunk;\n", "import {memo, useRef, useCallback, ReactElement, MouseEvent, useMemo, ReactNode} from 'react';\nimport classNames from 'classnames';\nimport {\n    ContextProps,\n    EventMap,\n    GutterType,\n    Provider,\n    ViewType,\n    RenderToken,\n    RenderGutter,\n    DEFAULT_CONTEXT_VALUE,\n} from '../context';\nimport Hunk from '../Hunk';\nimport {ChangeData, HunkData} from '../utils';\nimport {HunkTokens} from '../tokenize';\n\nexport type DiffType = 'add' | 'delete' | 'modify' | 'rename' | 'copy';\n\nexport interface DiffProps {\n    diffType: DiffType;\n    hunks: HunkData[];\n    viewType?: ViewType;\n    gutterType?: GutterType;\n    generateAnchorID?: (change: ChangeData) => string | undefined;\n    selectedChanges?: string[];\n    widgets?: Record<string, ReactNode>;\n    optimizeSelection?: boolean;\n    className?: string;\n    hunkClassName?: string;\n    lineClassName?: string;\n    generateLineClassName?: (params: {changes: ChangeData[], defaultGenerate: () => string}) => string | undefined;\n    gutterClassName?: string;\n    codeClassName?: string;\n    tokens?: HunkTokens | null;\n    renderToken?: RenderToken;\n    renderGutter?: RenderGutter;\n    gutterEvents?: EventMap;\n    codeEvents?: EventMap;\n    children?: (hunks: HunkData[]) => ReactElement | ReactElement[];\n}\n\nfunction noop() {}\n\nfunction findClosest(target: HTMLElement, className: string) {\n    let current: HTMLElement | null = target;\n    while (current && current !== document.documentElement && !current.classList.contains(className)) {\n        current = current.parentElement;\n    }\n\n    return current === document.documentElement ? null : current;\n}\n\nfunction setUserSelectStyle(element: Element, selectable: boolean) {\n    const value = selectable ? 'auto' : 'none';\n\n    if (element instanceof HTMLElement && element.style.userSelect !== value) {\n        element.style.userSelect = value; // eslint-disable-line no-param-reassign\n    }\n}\n\nfunction defaultRenderChildren(hunks: HunkData[]) {\n    const key = (hunk: HunkData) => `-${hunk.oldStart},${hunk.oldLines} +${hunk.newStart},${hunk.newLines}`;\n    return hunks.map(hunk => <Hunk key={key(hunk)} hunk={hunk} />);\n}\n\nfunction Diff(props: DiffProps) {\n    const {\n        diffType,\n        hunks,\n        optimizeSelection,\n        className,\n        hunkClassName = DEFAULT_CONTEXT_VALUE.hunkClassName,\n        lineClassName = DEFAULT_CONTEXT_VALUE.lineClassName,\n        generateLineClassName = DEFAULT_CONTEXT_VALUE.generateLineClassName,\n        gutterClassName = DEFAULT_CONTEXT_VALUE.gutterClassName,\n        codeClassName = DEFAULT_CONTEXT_VALUE.codeClassName,\n        gutterType = DEFAULT_CONTEXT_VALUE.gutterType,\n        viewType = DEFAULT_CONTEXT_VALUE.viewType,\n        gutterEvents = DEFAULT_CONTEXT_VALUE.gutterEvents,\n        codeEvents = DEFAULT_CONTEXT_VALUE.codeEvents,\n        generateAnchorID = DEFAULT_CONTEXT_VALUE.generateAnchorID,\n        selectedChanges = DEFAULT_CONTEXT_VALUE.selectedChanges,\n        widgets = DEFAULT_CONTEXT_VALUE.widgets,\n        renderGutter = DEFAULT_CONTEXT_VALUE.renderGutter,\n        tokens,\n        renderToken,\n        children = defaultRenderChildren,\n    } = props;\n    const root = useRef<HTMLTableElement>(null);\n    const enableColumnSelection = useCallback(\n        ({target, button}: MouseEvent<HTMLElement>) => {\n            if (button !== 0) {\n                return;\n            }\n\n            const closestCell = findClosest(target as HTMLElement, 'diff-code');\n\n            if (!closestCell || !closestCell.parentElement) {\n                return;\n            }\n\n            const selection = window.getSelection();\n            if (selection) {\n                selection.removeAllRanges();\n            }\n\n            const index = [...closestCell.parentElement.children].indexOf(closestCell);\n\n            if (index !== 1 && index !== 3) {\n                return;\n            }\n\n            const lines = root.current ? root.current.querySelectorAll('.diff-line') : [];\n            for (const line of lines) {\n                const cells = line.children;\n                setUserSelectStyle(cells[1], index === 1);\n                setUserSelectStyle(cells[3], index === 3);\n            }\n        },\n        []\n    );\n    const hideGutter = gutterType === 'none';\n    const monotonous = diffType === 'add' || diffType === 'delete';\n    const onTableMouseDown = (viewType === 'split' && !monotonous && optimizeSelection) ? enableColumnSelection : noop;\n    const cols = useMemo(\n        () => {\n            if (viewType === 'unified') {\n                return (\n                    <colgroup>\n                        {!hideGutter && <col className=\"diff-gutter-col\" />}\n                        {!hideGutter && <col className=\"diff-gutter-col\" />}\n                        <col />\n                    </colgroup>\n                );\n            }\n\n            if (monotonous) {\n                return (\n                    <colgroup>\n                        {!hideGutter && <col className=\"diff-gutter-col\" />}\n                        <col />\n                    </colgroup>\n                );\n            }\n\n            return (\n                <colgroup>\n                    {!hideGutter && <col className=\"diff-gutter-col\" />}\n                    <col />\n                    {!hideGutter && <col className=\"diff-gutter-col\" />}\n                    <col />\n                </colgroup>\n            );\n        },\n        [viewType, monotonous, hideGutter]\n    );\n    // TODO: in later versions, we can split context into multiple to reduce component render\n    const settingsContextValue = useMemo(\n        (): ContextProps => {\n            return {\n                hunkClassName,\n                lineClassName,\n                generateLineClassName,\n                gutterClassName,\n                codeClassName,\n                monotonous,\n                hideGutter,\n                viewType,\n                gutterType,\n                codeEvents,\n                gutterEvents,\n                generateAnchorID,\n                selectedChanges,\n                widgets,\n                renderGutter,\n                tokens,\n                renderToken,\n            };\n        },\n        [\n            codeClassName,\n            codeEvents,\n            generateAnchorID,\n            gutterClassName,\n            gutterEvents,\n            gutterType,\n            hideGutter,\n            hunkClassName,\n            lineClassName,\n            generateLineClassName,\n            monotonous,\n            renderGutter,\n            renderToken,\n            selectedChanges,\n            tokens,\n            viewType,\n            widgets,\n        ]\n    );\n\n    return (\n        <Provider value={settingsContextValue}>\n            <table\n                ref={root}\n                className={classNames('diff', `diff-${viewType}`, className)}\n                onMouseDown={onTableMouseDown}\n            >\n                {cols}\n                {children(hunks)}\n            </table>\n        </Provider>\n    );\n}\n\nexport default memo(Diff);\n", "/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar __DEV__ = process.env.NODE_ENV !== 'production';\n\nvar warning = function() {};\n\nif (__DEV__) {\n  var printWarning = function printWarning(format, args) {\n    var len = arguments.length;\n    args = new Array(len > 1 ? len - 1 : 0);\n    for (var key = 1; key < len; key++) {\n      args[key - 1] = arguments[key];\n    }\n    var argIndex = 0;\n    var message = 'Warning: ' +\n      format.replace(/%s/g, function() {\n        return args[argIndex++];\n      });\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  }\n\n  warning = function(condition, format, args) {\n    var len = arguments.length;\n    args = new Array(len > 2 ? len - 2 : 0);\n    for (var key = 2; key < len; key++) {\n      args[key - 2] = arguments[key];\n    }\n    if (format === undefined) {\n      throw new Error(\n          '`warning(condition, format, ...args)` requires a warning ' +\n          'message argument'\n      );\n    }\n    if (!condition) {\n      printWarning.apply(null, [format].concat(args));\n    }\n  };\n}\n\nmodule.exports = warning;\n", "import {Children, ReactNode} from 'react';\nimport classNames from 'classnames';\nimport {ActualDecorationProps} from './interface';\n\nexport default function SplitDecoration(props: ActualDecorationProps) {\n    const {hideGutter, monotonous, className, gutterClassName, contentClassName, children} = props;\n    const computedClassName = classNames('diff-decoration', className);\n    const computedGutterClassName = classNames('diff-decoration-gutter', gutterClassName);\n    const computedContentClassName = classNames('diff-decoration-content', contentClassName);\n    const columnCount = (hideGutter ? 2 : 4) / (monotonous ? 2 : 1);\n    const headerContentColSpan = columnCount - (hideGutter ? 0 : 1);\n\n    // One element spans all gutter and content cells\n    if (Children.count(children) === 1) {\n        return (\n            <tbody className={computedClassName}>\n                <tr>\n                    <td colSpan={columnCount} className={computedContentClassName}>\n                        {children}\n                    </td>\n                </tr>\n            </tbody>\n        );\n    }\n\n    const [gutter, content] = children as [ReactNode, ReactNode];\n\n    return (\n        <tbody className={computedClassName}>\n            <tr>\n                {!hideGutter && <td className={computedGutterClassName}>{gutter}</td>}\n                <td colSpan={headerContentColSpan} className={computedContentClassName}>{content}</td>\n            </tr>\n        </tbody>\n    );\n}\n", "import {Children, ReactNode} from 'react';\nimport classNames from 'classnames';\nimport {ActualDecorationProps} from './interface';\n\nexport default function UnifiedDecoration(props: ActualDecorationProps) {\n    const {hideGutter, className, gutterClassName, contentClassName, children} = props;\n    const computedClassName = classNames('diff-decoration', className);\n    const computedGutterClassName = classNames('diff-decoration-gutter', gutterClassName);\n    const computedContentClassName = classNames('diff-decoration-content', contentClassName);\n\n    // One element spans all gutter and content cells\n    if (Children.count(children) === 1) {\n        return (\n            <tbody className={computedClassName}>\n                <tr>\n                    <td colSpan={hideGutter ? 1 : 3} className={computedContentClassName}>\n                        {children}\n                    </td>\n                </tr>\n            </tbody>\n        );\n    }\n\n    const [gutter, content] = children as [ReactNode, ReactNode];\n\n    return (\n        <tbody className={computedClassName}>\n            <tr>\n                {!hideGutter && <td colSpan={2} className={computedGutterClassName}>{gutter}</td>}\n                <td className={computedContentClassName}>{content}</td>\n            </tr>\n        </tbody>\n    );\n}\n", "import {Children, ReactNode} from 'react';\nimport warning from 'warning';\nimport {useDiffSettings} from '../context';\nimport SplitDecoration from './SplitDecoration';\nimport UnifiedDecoration from './UnifiedDecoration';\n\nexport interface DecorationProps {\n    className?: string;\n    gutterClassName?: string;\n    contentClassName?: string;\n    children: ReactNode | [ReactNode, ReactNode];\n}\n\nexport default function Decoration(props: DecorationProps) {\n    const {\n        className = '',\n        gutterClassName = '',\n        contentClassName = '',\n        children,\n    } = props;\n    const {viewType, gutterType, monotonous} = useDiffSettings();\n    const RenderingDecoration = viewType === 'split' ? SplitDecoration : UnifiedDecoration;\n    const childrenCount = Children.count(children);\n    const hideGutter = gutterType === 'none';\n\n    warning(\n        childrenCount <= 2,\n        'Decoration only accepts a maxium of 2 children'\n    );\n\n    warning(\n        childrenCount < 2 || !hideGutter,\n        'Gutter element in decoration will not be rendered since hideGutter prop is set to true'\n    );\n\n\n    // TODO: maybe we should use union type to pass children\n    return (\n        <RenderingDecoration\n            hideGutter={hideGutter}\n            monotonous={monotonous}\n            className={className}\n            gutterClassName={gutterClassName}\n            contentClassName={contentClassName}\n        >\n            {children}\n        </RenderingDecoration>\n    );\n}\n", "/**\n * A specialized version of `baseAggregator` for arrays.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} setter The function to set `accumulator` values.\n * @param {Function} iteratee The iteratee to transform keys.\n * @param {Object} accumulator The initial aggregated object.\n * @returns {Function} Returns `accumulator`.\n */\nfunction arrayAggregator(array, setter, iteratee, accumulator) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    var value = array[index];\n    setter(accumulator, value, iteratee(value), array);\n  }\n  return accumulator;\n}\n\nmodule.exports = arrayAggregator;\n", "var isArrayLike = require('./isArrayLike');\n\n/**\n * Creates a `baseEach` or `baseEachRight` function.\n *\n * @private\n * @param {Function} eachFunc The function to iterate over a collection.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseEach(eachFunc, fromRight) {\n  return function(collection, iteratee) {\n    if (collection == null) {\n      return collection;\n    }\n    if (!isArrayLike(collection)) {\n      return eachFunc(collection, iteratee);\n    }\n    var length = collection.length,\n        index = fromRight ? length : -1,\n        iterable = Object(collection);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (iteratee(iterable[index], index, iterable) === false) {\n        break;\n      }\n    }\n    return collection;\n  };\n}\n\nmodule.exports = createBaseEach;\n", "var baseForOwn = require('./_baseForOwn'),\n    createBaseEach = require('./_createBaseEach');\n\n/**\n * The base implementation of `_.forEach` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n */\nvar baseEach = createBaseEach(baseForOwn);\n\nmodule.exports = baseEach;\n", "var baseEach = require('./_baseEach');\n\n/**\n * Aggregates elements of `collection` on `accumulator` with keys transformed\n * by `iteratee` and values set by `setter`.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} setter The function to set `accumulator` values.\n * @param {Function} iteratee The iteratee to transform keys.\n * @param {Object} accumulator The initial aggregated object.\n * @returns {Function} Returns `accumulator`.\n */\nfunction baseAggregator(collection, setter, iteratee, accumulator) {\n  baseEach(collection, function(value, key, collection) {\n    setter(accumulator, value, iteratee(value), collection);\n  });\n  return accumulator;\n}\n\nmodule.exports = baseAggregator;\n", "var arrayAggregator = require('./_arrayAggregator'),\n    baseAggregator = require('./_baseAggregator'),\n    baseIteratee = require('./_baseIteratee'),\n    isArray = require('./isArray');\n\n/**\n * Creates a function like `_.groupBy`.\n *\n * @private\n * @param {Function} setter The function to set accumulator values.\n * @param {Function} [initializer] The accumulator object initializer.\n * @returns {Function} Returns the new aggregator function.\n */\nfunction createAggregator(setter, initializer) {\n  return function(collection, iteratee) {\n    var func = isArray(collection) ? arrayAggregator : baseAggregator,\n        accumulator = initializer ? initializer() : {};\n\n    return func(collection, setter, baseIteratee(iteratee, 2), accumulator);\n  };\n}\n\nmodule.exports = createAggregator;\n", "var baseAssignValue = require('./_baseAssignValue'),\n    createAggregator = require('./_createAggregator');\n\n/**\n * Creates an object composed of keys generated from the results of running\n * each element of `collection` thru `iteratee`. The corresponding value of\n * each key is the last element responsible for generating the key. The\n * iteratee is invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n * @returns {Object} Returns the composed aggregate object.\n * @example\n *\n * var array = [\n *   { 'dir': 'left', 'code': 97 },\n *   { 'dir': 'right', 'code': 100 }\n * ];\n *\n * _.keyBy(array, function(o) {\n *   return String.fromCharCode(o.code);\n * });\n * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n *\n * _.keyBy(array, 'dir');\n * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }\n */\nvar keyBy = createAggregator(function(result, value, key) {\n  baseAssignValue(result, key, value);\n});\n\nmodule.exports = keyBy;\n", "var Symbol = require('./_Symbol'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray');\n\n/** Built-in value references. */\nvar spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;\n\n/**\n * Checks if `value` is a flattenable `arguments` object or array.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n */\nfunction isFlattenable(value) {\n  return isArray(value) || isArguments(value) ||\n    !!(spreadableSymbol && value && value[spreadableSymbol]);\n}\n\nmodule.exports = isFlattenable;\n", "var arrayPush = require('./_arrayPush'),\n    isFlattenable = require('./_isFlattenable');\n\n/**\n * The base implementation of `_.flatten` with support for restricting flattening.\n *\n * @private\n * @param {Array} array The array to flatten.\n * @param {number} depth The maximum recursion depth.\n * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n * @param {Array} [result=[]] The initial result value.\n * @returns {Array} Returns the new flattened array.\n */\nfunction baseFlatten(array, depth, predicate, isStrict, result) {\n  var index = -1,\n      length = array.length;\n\n  predicate || (predicate = isFlattenable);\n  result || (result = []);\n\n  while (++index < length) {\n    var value = array[index];\n    if (depth > 0 && predicate(value)) {\n      if (depth > 1) {\n        // Recursively flatten arrays (susceptible to call stack limits).\n        baseFlatten(value, depth - 1, predicate, isStrict, result);\n      } else {\n        arrayPush(result, value);\n      }\n    } else if (!isStrict) {\n      result[result.length] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseFlatten;\n", "var baseEach = require('./_baseEach'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * The base implementation of `_.map` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction baseMap(collection, iteratee) {\n  var index = -1,\n      result = isArrayLike(collection) ? Array(collection.length) : [];\n\n  baseEach(collection, function(value, key, collection) {\n    result[++index] = iteratee(value, key, collection);\n  });\n  return result;\n}\n\nmodule.exports = baseMap;\n", "var arrayMap = require('./_arrayMap'),\n    baseIteratee = require('./_baseIteratee'),\n    baseMap = require('./_baseMap'),\n    isArray = require('./isArray');\n\n/**\n * Creates an array of values by running each element in `collection` thru\n * `iteratee`. The iteratee is invoked with three arguments:\n * (value, index|key, collection).\n *\n * Many lodash methods are guarded to work as iteratees for methods like\n * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n *\n * The guarded methods are:\n * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,\n * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,\n * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,\n * `template`, `trim`, `trimEnd`, `trimStart`, and `words`\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n * @example\n *\n * function square(n) {\n *   return n * n;\n * }\n *\n * _.map([4, 8], square);\n * // => [16, 64]\n *\n * _.map({ 'a': 4, 'b': 8 }, square);\n * // => [16, 64] (iteration order is not guaranteed)\n *\n * var users = [\n *   { 'user': 'barney' },\n *   { 'user': 'fred' }\n * ];\n *\n * // The `_.property` iteratee shorthand.\n * _.map(users, 'user');\n * // => ['barney', 'fred']\n */\nfunction map(collection, iteratee) {\n  var func = isArray(collection) ? arrayMap : baseMap;\n  return func(collection, baseIteratee(iteratee, 3));\n}\n\nmodule.exports = map;\n", "var baseFlatten = require('./_baseFlatten'),\n    map = require('./map');\n\n/**\n * Creates a flattened array of values by running each element in `collection`\n * thru `iteratee` and flattening the mapped results. The iteratee is invoked\n * with three arguments: (value, index|key, collection).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new flattened array.\n * @example\n *\n * function duplicate(n) {\n *   return [n, n];\n * }\n *\n * _.flatMap([1, 2], duplicate);\n * // => [1, 1, 2, 2]\n */\nfunction flatMap(collection, iteratee) {\n  return baseFlatten(map(collection, iteratee), 1);\n}\n\nmodule.exports = flatMap;\n", "import {flatMap, keyBy} from 'lodash';\nimport type {AST, RefractorNode, highlight} from 'refractor';\nimport {Side} from '../interface';\nimport {computeOldLineNumber, computeNewLineNumber, ChangeData, HunkData, isDelete, isInsert, isNormal} from '../utils';\nimport {Pair, TokenNode} from './interface';\n\ninterface Refractor {\n    highlight: typeof highlight;\n}\n\ninterface HunkApplyState {\n    newStart: number;\n    changes: ChangeData[];\n}\n\n// This function mutates `linesOfCode` argument.\nfunction applyHunk(linesOfCode: string[], {newStart, changes}: HunkApplyState) {\n    // Within each hunk, changes are continous, so we can use a sequential algorithm here.\n    //\n    // When `linesOfCode` is received here, it has already patched by previous hunk,\n    // thus the starting line number has changed due to possible unbanlanced deletions and insertions,\n    // we should use `newStart` as the first line number of current reduce.\n    const [patchedLines] = changes.reduce<[string[], number]>(\n        ([lines, cursor], change) => {\n            if (isDelete(change)) {\n                lines.splice(cursor, 1);\n                return [lines, cursor];\n            }\n\n            if (isInsert(change)) {\n                lines.splice(cursor, 0, change.content);\n            }\n            return [lines, cursor + 1];\n        },\n        [linesOfCode, newStart - 1]\n    );\n\n    return patchedLines;\n}\n\nfunction applyDiff(oldSource: string, hunks: HunkData[]): string {\n    // `hunks` must be ordered here.\n    const patchedLines = hunks.reduce(applyHunk, oldSource.split('\\n'));\n    return patchedLines.join('\\n');\n}\n\nfunction mapChanges<T>(changes: ChangeData[], side: Side, toValue: (change: ChangeData | undefined) => T): T[] {\n    if (!changes.length) {\n        return [];\n    }\n\n    const computeLineNumber = side === 'old' ? computeOldLineNumber : computeNewLineNumber;\n    const changesByLineNumber = keyBy(changes, computeLineNumber);\n    const maxLineNumber = computeLineNumber(changes[changes.length - 1]);\n    // TODO: why don't we start from the first change's line number?\n    return Array.from({length: maxLineNumber}).map((value, i) => toValue(changesByLineNumber[i + 1]));\n}\n\nfunction groupChanges(hunks: HunkData[]): Pair<ChangeData[]> {\n    const changes = flatMap(hunks, hunk => hunk.changes);\n    return changes.reduce<[ChangeData[], ChangeData[]]>(\n        ([oldChanges, newChanges], change) => {\n            if (isNormal(change)) {\n                oldChanges.push(change);\n                newChanges.push(change);\n            }\n            else if (isDelete(change)) {\n                oldChanges.push(change);\n            }\n            else {\n                newChanges.push(change);\n            }\n\n            return [oldChanges, newChanges];\n        },\n        [[], []]\n    );\n}\n\nfunction toTextPair(hunks: HunkData[]): Pair<string> {\n    const [oldChanges, newChanges] = groupChanges(hunks);\n    const toText = (change: ChangeData | undefined) => (change ? change.content : '');\n    const oldText = mapChanges(oldChanges, 'old', toText).join('\\n');\n    const newText = mapChanges(newChanges, 'new', toText).join('\\n');\n    return [oldText, newText];\n}\n\nfunction createRoot(children: RefractorNode[]): TokenNode {\n    return {type: 'root', children: children};\n}\n\nexport interface ToTokenTreeOptionsNoHighlight {\n    highlight?: false;\n    oldSource?: string;\n}\n\nexport interface ToTokenTreeOptionsHighlight {\n    highlight: true;\n    refractor: Refractor;\n    oldSource?: string;\n    language: string;\n}\n\nexport type ToTokenTreeOptions = ToTokenTreeOptionsNoHighlight | ToTokenTreeOptionsHighlight;\n\nexport default function toTokenTrees(hunks: HunkData[], options: ToTokenTreeOptions): Pair<TokenNode> {\n    if (options.oldSource) {\n        const newSource = applyDiff(options.oldSource, hunks);\n        const highlightText = options.highlight\n            ? (text: string) => options.refractor.highlight(text, options.language)\n            : (text: string): AST.Text[] => [{type: 'text', value: text}];\n\n        return [\n            createRoot(highlightText(options.oldSource)),\n            createRoot(highlightText(newSource)),\n        ];\n    }\n\n    const [oldText, newText] = toTextPair(hunks);\n    const toTree = options.highlight\n        ? (text: string) => createRoot(options.refractor.highlight(text, options.language))\n        : (text: string) => createRoot([{type: 'text', value: text}]);\n\n    return [toTree(oldText), toTree(newText)];\n}\n", "import {ProcessingNode, TextNode, TokenPath} from './interface';\n\nexport function clone(path: TokenPath): TokenPath {\n    return path.map(node => ({...node}));\n}\n\nexport function replace(path: TokenPath, leaf: ProcessingNode): TokenPath {\n    return [...clone(path.slice(0, -1)), leaf];\n}\n\nexport function wrap(path: TokenPath, parent: ProcessingNode): TokenPath {\n    return [parent, ...clone(path)];\n}\n\nfunction isTextNode(node: ProcessingNode): node is TextNode {\n    return node.type === 'text';\n}\n\nexport function leafOf(path: TokenPath): TextNode {\n    const last = path[path.length - 1];\n\n    if (isTextNode(last)) {\n        return last;\n    }\n\n    throw new Error(`Invalid token path with leaf of type ${last.type}`);\n}\n\nexport function split(path: TokenPath, splitStart: number, splitEnd: number, wrapSplitNode: ProcessingNode) {\n    const parents = path.slice(0, -1);\n    const leaf = leafOf(path);\n    const output = [];\n\n    if (splitEnd <= 0 || splitStart >= leaf?.value.length) {\n        return [path];\n    }\n\n    const split = (start: number, end?: number) => {\n        const value = leaf.value.slice(start, end);\n        return [...parents, {...leaf, value}];\n    };\n\n    if (splitStart > 0) {\n        const head = split(0, splitStart);\n        output.push(clone(head));\n    }\n\n    const body = split(Math.max(splitStart, 0), splitEnd);\n    output.push(wrapSplitNode ? wrap(body, wrapSplitNode) : clone(body));\n\n    if (splitEnd < leaf.value.length) {\n        const tail = split(splitEnd);\n        output.push(clone(tail));\n    }\n\n    return output;\n}\n", "import {TokenNode, TokenPath} from './interface';\nimport {clone, leafOf, replace} from './utils';\n\nfunction treeToPathList(node: TokenNode, output: TokenPath[] = [], path: TokenPath = []): TokenPath[] {\n    if (node.children) {\n        const {children, ...nodeToUse} = node;\n        path.push(nodeToUse);\n        for (const child of children) {\n            treeToPathList(child, output, path);\n        }\n        path.pop();\n    }\n    else {\n        output.push(clone([...path.slice(1), node]));\n    }\n\n    return output;\n}\n\nfunction splitPathToLines(path: TokenPath) {\n    const leaf = leafOf(path);\n\n    if (!leaf.value.includes('\\n')) {\n        return [path];\n    }\n\n    const linesOfText = leaf.value.split('\\n');\n    return linesOfText.map(line => replace(path, {...leaf, value: line}));\n}\n\nfunction splitByLineBreak(paths: TokenPath[]): TokenPath[][] {\n    return paths.reduce<TokenPath[][]>(\n        (lines, path) => {\n            const currentLine = lines[lines.length - 1];\n            const [currentRemaining, ...nextLines] = splitPathToLines(path);\n            return [\n                ...lines.slice(0, -1),\n                [...currentLine, currentRemaining],\n                ...nextLines.map(path => [path]),\n            ];\n        },\n        [[]]\n    );\n}\n\nexport default function normalizeToLines(tree: TokenNode): TokenPath[][] {\n    const paths = treeToPathList(tree);\n    const linesOfPaths = splitByLineBreak(paths);\n    return linesOfPaths;\n}\n", "var baseIsEqual = require('./_baseIsEqual');\n\n/**\n * This method is like `_.isEqual` except that it accepts `customizer` which\n * is invoked to compare values. If `customizer` returns `undefined`, comparisons\n * are handled by the method instead. The `customizer` is invoked with up to\n * six arguments: (objValue, othValue [, index|key, object, other, stack]).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * function isGreeting(value) {\n *   return /^h(?:i|ello)$/.test(value);\n * }\n *\n * function customizer(objValue, othValue) {\n *   if (isGreeting(objValue) && isGreeting(othValue)) {\n *     return true;\n *   }\n * }\n *\n * var array = ['hello', 'goodbye'];\n * var other = ['hi', 'goodbye'];\n *\n * _.isEqualWith(array, other, customizer);\n * // => true\n */\nfunction isEqualWith(value, other, customizer) {\n  customizer = typeof customizer == 'function' ? customizer : undefined;\n  var result = customizer ? customizer(value, other) : undefined;\n  return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;\n}\n\nmodule.exports = isEqualWith;\n", "var baseIsEqual = require('./_baseIsEqual');\n\n/**\n * Performs a deep comparison between two values to determine if they are\n * equivalent.\n *\n * **Note:** This method supports comparing arrays, array buffers, booleans,\n * date objects, error objects, maps, numbers, `Object` objects, regexes,\n * sets, strings, symbols, and typed arrays. `Object` objects are compared\n * by their own, not inherited, enumerable properties. Functions and DOM\n * nodes are compared by strict equality, i.e. `===`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.isEqual(object, other);\n * // => true\n *\n * object === other;\n * // => false\n */\nfunction isEqual(value, other) {\n  return baseIsEqual(value, other);\n}\n\nmodule.exports = isEqual;\n", "/**\n * Gets the last element of `array`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to query.\n * @returns {*} Returns the last element of `array`.\n * @example\n *\n * _.last([1, 2, 3]);\n * // => 3\n */\nfunction last(array) {\n  var length = array == null ? 0 : array.length;\n  return length ? array[length - 1] : undefined;\n}\n\nmodule.exports = last;\n", "import {last, isEqual, isEqualWith} from 'lodash';\nimport {ProcessingNode, TokenNode, TokenPath} from './interface';\n\nfunction areNodesMeregable(x: TokenNode, y: TokenNode): boolean {\n\n    if (x.type !== y.type) {\n        return false;\n    }\n\n    if (x.type === 'text') {\n        return true;\n    }\n\n    if (!x.children || !y.children) {\n        return false;\n    }\n\n    return isEqualWith(x, y, (x, y, name) => (name === 'chlidren' || isEqual(x, y)));\n}\n\nfunction mergeNode(x: ProcessingNode, y: ProcessingNode) {\n    if ('value' in x && 'value' in y) {\n        return {\n            ...x,\n            value: `${x.value}${y.value}`,\n        };\n    }\n\n    return x;\n}\n\nfunction attachNode(parent: TokenNode, node: TokenNode): TokenNode {\n    if (!parent.children) {\n        throw new Error('parent node missing children property');\n    }\n\n    const previousSibling = last(parent.children);\n\n    if (previousSibling && areNodesMeregable(previousSibling, node)) {\n        /* eslint-disable no-param-reassign */\n        parent.children[parent.children.length - 1] = mergeNode(previousSibling, node);\n        /* eslint-enable no-param-reassign */\n    }\n    else {\n        parent.children.push(node);\n    }\n\n    const leaf = parent.children[parent.children.length - 1];\n    return leaf;\n}\n\nexport default function backToTree(pathList: TokenPath[]): TokenNode {\n    const root: TokenNode = {type: 'root', children: []};\n\n    for (const path of pathList) {\n        path.reduce<TokenNode>(\n            (parent: TokenNode, node: ProcessingNode, i: number) => {\n                const nodeToUse: TokenNode = i === path.length - 1 ? {...node} : {...node, children: []};\n                return attachNode(parent, nodeToUse);\n            },\n            root\n        );\n    }\n\n    return root;\n}\n", "var baseAssignValue = require('./_baseAssignValue'),\n    createAggregator = require('./_createAggregator');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an object composed of keys generated from the results of running\n * each element of `collection` thru `iteratee`. The order of grouped values\n * is determined by the order they occur in `collection`. The corresponding\n * value of each key is an array of elements responsible for generating the\n * key. The iteratee is invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n * @returns {Object} Returns the composed aggregate object.\n * @example\n *\n * _.groupBy([6.1, 4.2, 6.3], Math.floor);\n * // => { '4': [4.2], '6': [6.1, 6.3] }\n *\n * // The `_.property` iteratee shorthand.\n * _.groupBy(['one', 'two', 'three'], 'length');\n * // => { '3': ['one', 'two'], '5': ['three'] }\n */\nvar groupBy = createAggregator(function(result, value, key) {\n  if (hasOwnProperty.call(result, key)) {\n    result[key].push(value);\n  } else {\n    baseAssignValue(result, key, [value]);\n  }\n});\n\nmodule.exports = groupBy;\n", "var baseKeys = require('./_baseKeys'),\n    getTag = require('./_getTag'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isArrayLike = require('./isArrayLike'),\n    isBuffer = require('./isBuffer'),\n    isPrototype = require('./_isPrototype'),\n    isTypedArray = require('./isTypedArray');\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]',\n    setTag = '[object Set]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if `value` is an empty object, collection, map, or set.\n *\n * Objects are considered empty if they have no own enumerable string keyed\n * properties.\n *\n * Array-like values such as `arguments` objects, arrays, buffers, strings, or\n * jQuery-like collections are considered empty if they have a `length` of `0`.\n * Similarly, maps and sets are considered empty if they have a `size` of `0`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is empty, else `false`.\n * @example\n *\n * _.isEmpty(null);\n * // => true\n *\n * _.isEmpty(true);\n * // => true\n *\n * _.isEmpty(1);\n * // => true\n *\n * _.isEmpty([1, 2, 3]);\n * // => false\n *\n * _.isEmpty({ 'a': 1 });\n * // => false\n */\nfunction isEmpty(value) {\n  if (value == null) {\n    return true;\n  }\n  if (isArrayLike(value) &&\n      (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||\n        isBuffer(value) || isTypedArray(value) || isArguments(value))) {\n    return !value.length;\n  }\n  var tag = getTag(value);\n  if (tag == mapTag || tag == setTag) {\n    return !value.size;\n  }\n  if (isPrototype(value)) {\n    return !baseKeys(value).length;\n  }\n  for (var key in value) {\n    if (hasOwnProperty.call(value, key)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nmodule.exports = isEmpty;\n", "/**\n * @file 在高亮的语法节点上插入代码定义与引用的信息\n * @author zhanglili\n */\n\nimport {isEmpty, groupBy} from 'lodash';\nimport {TokenizeEnhancer, TokenPath} from './interface';\nimport {leafOf, split} from './utils';\n\nexport interface RangeTokenNode {\n    type: string;\n    lineNumber: number;\n    start: number;\n    length: number;\n}\n\nconst splitPathToEncloseRange = (paths: TokenPath[], node: RangeTokenNode) => {\n    const {start, length} = node;\n    const rangeEnd = start + length;\n    const [output] = paths.reduce<[TokenPath[], number]>(\n        ([output, nodeStart], path) => {\n            const leaf = leafOf(path);\n            const nodeEnd = nodeStart + leaf.value.length;\n\n            if (nodeStart > rangeEnd || nodeEnd < start) {\n                output.push(path);\n            }\n            else {\n                const segments = split(path, start - nodeStart, rangeEnd - nodeStart, node);\n                output.push(...segments);\n            }\n\n            return [output, nodeEnd];\n        },\n        [[], 0]\n    );\n\n    return output;\n};\n\nfunction pickRangesFromPath(paths: TokenPath[], ranges: RangeTokenNode[]) {\n    if (isEmpty(ranges)) {\n        return paths;\n    }\n\n    return ranges.reduce(splitPathToEncloseRange, paths);\n}\n\nfunction process(linesOfPaths: TokenPath[][], ranges: RangeTokenNode[]) {\n    const rangesByLine = groupBy(ranges, 'lineNumber');\n    return linesOfPaths.map((line, i) => pickRangesFromPath(line, rangesByLine[i + 1]));\n}\n\nexport default function pickRanges(oldRanges: RangeTokenNode[], newRanges: RangeTokenNode[]): TokenizeEnhancer {\n    return ([oldLinesOfPaths, newLinesOfPaths]) => [\n        process(oldLinesOfPaths, oldRanges),\n        process(newLinesOfPaths, newRanges),\n    ];\n}\n", "var baseFlatten = require('./_baseFlatten');\n\n/**\n * Flattens `array` a single level deep.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to flatten.\n * @returns {Array} Returns the new flattened array.\n * @example\n *\n * _.flatten([1, [2, [3, [4]], 5]]);\n * // => [1, 2, [3, [4]], 5]\n */\nfunction flatten(array) {\n  var length = array == null ? 0 : array.length;\n  return length ? baseFlatten(array, 1) : [];\n}\n\nmodule.exports = flatten;\n", "var baseFindIndex = require('./_baseFindIndex'),\n    baseIteratee = require('./_baseIteratee'),\n    toInteger = require('./toInteger');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * This method is like `_.find` except that it returns the index of the first\n * element `predicate` returns truthy for instead of the element itself.\n *\n * @static\n * @memberOf _\n * @since 1.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {number} Returns the index of the found element, else `-1`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'active': false },\n *   { 'user': 'fred',    'active': false },\n *   { 'user': 'pebbles', 'active': true }\n * ];\n *\n * _.findIndex(users, function(o) { return o.user == 'barney'; });\n * // => 0\n *\n * // The `_.matches` iteratee shorthand.\n * _.findIndex(users, { 'user': 'fred', 'active': false });\n * // => 1\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.findIndex(users, ['active', false]);\n * // => 0\n *\n * // The `_.property` iteratee shorthand.\n * _.findIndex(users, 'active');\n * // => 2\n */\nfunction findIndex(array, predicate, fromIndex) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return -1;\n  }\n  var index = fromIndex == null ? 0 : toInteger(fromIndex);\n  if (index < 0) {\n    index = nativeMax(length + index, 0);\n  }\n  return baseFindIndex(array, baseIteratee(predicate, 3), index);\n}\n\nmodule.exports = findIndex;\n", "/**\n * Diff Match and Patch\n * Copyright 2018 The diff-match-patch Authors.\n * https://github.com/google/diff-match-patch\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Computes the difference between two texts to create a patch.\n * Applies the patch onto another text, allowing for errors.\n * @author fraser@google.com (Neil Fraser)\n */\n\n/**\n * Class containing the diff, match and patch methods.\n * @constructor\n */\nvar diff_match_patch = function() {\n\n  // Defaults.\n  // Redefine these in your program to override the defaults.\n\n  // Number of seconds to map a diff before giving up (0 for infinity).\n  this.Diff_Timeout = 1.0;\n  // Cost of an empty edit operation in terms of edit characters.\n  this.Diff_EditCost = 4;\n  // At what point is no match declared (0.0 = perfection, 1.0 = very loose).\n  this.Match_Threshold = 0.5;\n  // How far to search for a match (0 = exact location, 1000+ = broad match).\n  // A match this many characters away from the expected location will add\n  // 1.0 to the score (0.0 is a perfect match).\n  this.Match_Distance = 1000;\n  // When deleting a large block of text (over ~64 characters), how close do\n  // the contents have to be to match the expected contents. (0.0 = perfection,\n  // 1.0 = very loose).  Note that Match_Threshold controls how closely the\n  // end points of a delete need to match.\n  this.Patch_DeleteThreshold = 0.5;\n  // Chunk size for context length.\n  this.Patch_Margin = 4;\n\n  // The number of bits in an int.\n  this.Match_MaxBits = 32;\n};\n\n\n//  DIFF FUNCTIONS\n\n\n/**\n * The data structure representing a diff is an array of tuples:\n * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n */\nvar DIFF_DELETE = -1;\nvar DIFF_INSERT = 1;\nvar DIFF_EQUAL = 0;\n\n/**\n * Class representing one diff tuple.\n * ~Attempts to look like a two-element array (which is what this used to be).~\n * Constructor returns an actual two-element array, to allow destructing @JackuB\n * See https://github.com/JackuB/diff-match-patch/issues/14 for details\n * @param {number} op Operation, one of: DIFF_DELETE, DIFF_INSERT, DIFF_EQUAL.\n * @param {string} text Text to be deleted, inserted, or retained.\n * @constructor\n */\ndiff_match_patch.Diff = function(op, text) {\n  return [op, text];\n};\n\n/**\n * Find the differences between two texts.  Simplifies the problem by stripping\n * any common prefix or suffix off the texts before diffing.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {boolean=} opt_checklines Optional speedup flag. If present and false,\n *     then don't run a line-level diff first to identify the changed areas.\n *     Defaults to true, which does a faster, slightly less optimal diff.\n * @param {number=} opt_deadline Optional time when the diff should be complete\n *     by.  Used internally for recursive calls.  Users should set DiffTimeout\n *     instead.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines,\n    opt_deadline) {\n  // Set a deadline by which time the diff must be complete.\n  if (typeof opt_deadline == 'undefined') {\n    if (this.Diff_Timeout <= 0) {\n      opt_deadline = Number.MAX_VALUE;\n    } else {\n      opt_deadline = (new Date).getTime() + this.Diff_Timeout * 1000;\n    }\n  }\n  var deadline = opt_deadline;\n\n  // Check for null inputs.\n  if (text1 == null || text2 == null) {\n    throw new Error('Null input. (diff_main)');\n  }\n\n  // Check for equality (speedup).\n  if (text1 == text2) {\n    if (text1) {\n      return [new diff_match_patch.Diff(DIFF_EQUAL, text1)];\n    }\n    return [];\n  }\n\n  if (typeof opt_checklines == 'undefined') {\n    opt_checklines = true;\n  }\n  var checklines = opt_checklines;\n\n  // Trim off common prefix (speedup).\n  var commonlength = this.diff_commonPrefix(text1, text2);\n  var commonprefix = text1.substring(0, commonlength);\n  text1 = text1.substring(commonlength);\n  text2 = text2.substring(commonlength);\n\n  // Trim off common suffix (speedup).\n  commonlength = this.diff_commonSuffix(text1, text2);\n  var commonsuffix = text1.substring(text1.length - commonlength);\n  text1 = text1.substring(0, text1.length - commonlength);\n  text2 = text2.substring(0, text2.length - commonlength);\n\n  // Compute the diff on the middle block.\n  var diffs = this.diff_compute_(text1, text2, checklines, deadline);\n\n  // Restore the prefix and suffix.\n  if (commonprefix) {\n    diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, commonprefix));\n  }\n  if (commonsuffix) {\n    diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, commonsuffix));\n  }\n  this.diff_cleanupMerge(diffs);\n  return diffs;\n};\n\n\n/**\n * Find the differences between two texts.  Assumes that the texts do not\n * have any common prefix or suffix.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {boolean} checklines Speedup flag.  If false, then don't run a\n *     line-level diff first to identify the changed areas.\n *     If true, then run a faster, slightly less optimal diff.\n * @param {number} deadline Time when the diff should be complete by.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_compute_ = function(text1, text2, checklines,\n    deadline) {\n  var diffs;\n\n  if (!text1) {\n    // Just add some text (speedup).\n    return [new diff_match_patch.Diff(DIFF_INSERT, text2)];\n  }\n\n  if (!text2) {\n    // Just delete some text (speedup).\n    return [new diff_match_patch.Diff(DIFF_DELETE, text1)];\n  }\n\n  var longtext = text1.length > text2.length ? text1 : text2;\n  var shorttext = text1.length > text2.length ? text2 : text1;\n  var i = longtext.indexOf(shorttext);\n  if (i != -1) {\n    // Shorter text is inside the longer text (speedup).\n    diffs = [new diff_match_patch.Diff(DIFF_INSERT, longtext.substring(0, i)),\n             new diff_match_patch.Diff(DIFF_EQUAL, shorttext),\n             new diff_match_patch.Diff(DIFF_INSERT,\n                 longtext.substring(i + shorttext.length))];\n    // Swap insertions for deletions if diff is reversed.\n    if (text1.length > text2.length) {\n      diffs[0][0] = diffs[2][0] = DIFF_DELETE;\n    }\n    return diffs;\n  }\n\n  if (shorttext.length == 1) {\n    // Single character string.\n    // After the previous speedup, the character can't be an equality.\n    return [new diff_match_patch.Diff(DIFF_DELETE, text1),\n            new diff_match_patch.Diff(DIFF_INSERT, text2)];\n  }\n\n  // Check to see if the problem can be split in two.\n  var hm = this.diff_halfMatch_(text1, text2);\n  if (hm) {\n    // A half-match was found, sort out the return data.\n    var text1_a = hm[0];\n    var text1_b = hm[1];\n    var text2_a = hm[2];\n    var text2_b = hm[3];\n    var mid_common = hm[4];\n    // Send both pairs off for separate processing.\n    var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);\n    var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);\n    // Merge the results.\n    return diffs_a.concat([new diff_match_patch.Diff(DIFF_EQUAL, mid_common)],\n                          diffs_b);\n  }\n\n  if (checklines && text1.length > 100 && text2.length > 100) {\n    return this.diff_lineMode_(text1, text2, deadline);\n  }\n\n  return this.diff_bisect_(text1, text2, deadline);\n};\n\n\n/**\n * Do a quick line-level diff on both strings, then rediff the parts for\n * greater accuracy.\n * This speedup can produce non-minimal diffs.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} deadline Time when the diff should be complete by.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_lineMode_ = function(text1, text2, deadline) {\n  // Scan the text on a line-by-line basis first.\n  var a = this.diff_linesToChars_(text1, text2);\n  text1 = a.chars1;\n  text2 = a.chars2;\n  var linearray = a.lineArray;\n\n  var diffs = this.diff_main(text1, text2, false, deadline);\n\n  // Convert the diff back to original text.\n  this.diff_charsToLines_(diffs, linearray);\n  // Eliminate freak matches (e.g. blank lines)\n  this.diff_cleanupSemantic(diffs);\n\n  // Rediff any replacement blocks, this time character-by-character.\n  // Add a dummy entry at the end.\n  diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, ''));\n  var pointer = 0;\n  var count_delete = 0;\n  var count_insert = 0;\n  var text_delete = '';\n  var text_insert = '';\n  while (pointer < diffs.length) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        count_insert++;\n        text_insert += diffs[pointer][1];\n        break;\n      case DIFF_DELETE:\n        count_delete++;\n        text_delete += diffs[pointer][1];\n        break;\n      case DIFF_EQUAL:\n        // Upon reaching an equality, check for prior redundancies.\n        if (count_delete >= 1 && count_insert >= 1) {\n          // Delete the offending records and add the merged ones.\n          diffs.splice(pointer - count_delete - count_insert,\n                       count_delete + count_insert);\n          pointer = pointer - count_delete - count_insert;\n          var subDiff =\n              this.diff_main(text_delete, text_insert, false, deadline);\n          for (var j = subDiff.length - 1; j >= 0; j--) {\n            diffs.splice(pointer, 0, subDiff[j]);\n          }\n          pointer = pointer + subDiff.length;\n        }\n        count_insert = 0;\n        count_delete = 0;\n        text_delete = '';\n        text_insert = '';\n        break;\n    }\n    pointer++;\n  }\n  diffs.pop();  // Remove the dummy entry at the end.\n\n  return diffs;\n};\n\n\n/**\n * Find the 'middle snake' of a diff, split the problem in two\n * and return the recursively constructed diff.\n * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} deadline Time at which to bail if not yet complete.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_bisect_ = function(text1, text2, deadline) {\n  // Cache the text lengths to prevent multiple calls.\n  var text1_length = text1.length;\n  var text2_length = text2.length;\n  var max_d = Math.ceil((text1_length + text2_length) / 2);\n  var v_offset = max_d;\n  var v_length = 2 * max_d;\n  var v1 = new Array(v_length);\n  var v2 = new Array(v_length);\n  // Setting all elements to -1 is faster in Chrome & Firefox than mixing\n  // integers and undefined.\n  for (var x = 0; x < v_length; x++) {\n    v1[x] = -1;\n    v2[x] = -1;\n  }\n  v1[v_offset + 1] = 0;\n  v2[v_offset + 1] = 0;\n  var delta = text1_length - text2_length;\n  // If the total number of characters is odd, then the front path will collide\n  // with the reverse path.\n  var front = (delta % 2 != 0);\n  // Offsets for start and end of k loop.\n  // Prevents mapping of space beyond the grid.\n  var k1start = 0;\n  var k1end = 0;\n  var k2start = 0;\n  var k2end = 0;\n  for (var d = 0; d < max_d; d++) {\n    // Bail out if deadline is reached.\n    if ((new Date()).getTime() > deadline) {\n      break;\n    }\n\n    // Walk the front path one step.\n    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\n      var k1_offset = v_offset + k1;\n      var x1;\n      if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {\n        x1 = v1[k1_offset + 1];\n      } else {\n        x1 = v1[k1_offset - 1] + 1;\n      }\n      var y1 = x1 - k1;\n      while (x1 < text1_length && y1 < text2_length &&\n             text1.charAt(x1) == text2.charAt(y1)) {\n        x1++;\n        y1++;\n      }\n      v1[k1_offset] = x1;\n      if (x1 > text1_length) {\n        // Ran off the right of the graph.\n        k1end += 2;\n      } else if (y1 > text2_length) {\n        // Ran off the bottom of the graph.\n        k1start += 2;\n      } else if (front) {\n        var k2_offset = v_offset + delta - k1;\n        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {\n          // Mirror x2 onto top-left coordinate system.\n          var x2 = text1_length - v2[k2_offset];\n          if (x1 >= x2) {\n            // Overlap detected.\n            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\n          }\n        }\n      }\n    }\n\n    // Walk the reverse path one step.\n    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\n      var k2_offset = v_offset + k2;\n      var x2;\n      if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {\n        x2 = v2[k2_offset + 1];\n      } else {\n        x2 = v2[k2_offset - 1] + 1;\n      }\n      var y2 = x2 - k2;\n      while (x2 < text1_length && y2 < text2_length &&\n             text1.charAt(text1_length - x2 - 1) ==\n             text2.charAt(text2_length - y2 - 1)) {\n        x2++;\n        y2++;\n      }\n      v2[k2_offset] = x2;\n      if (x2 > text1_length) {\n        // Ran off the left of the graph.\n        k2end += 2;\n      } else if (y2 > text2_length) {\n        // Ran off the top of the graph.\n        k2start += 2;\n      } else if (!front) {\n        var k1_offset = v_offset + delta - k2;\n        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {\n          var x1 = v1[k1_offset];\n          var y1 = v_offset + x1 - k1_offset;\n          // Mirror x2 onto top-left coordinate system.\n          x2 = text1_length - x2;\n          if (x1 >= x2) {\n            // Overlap detected.\n            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\n          }\n        }\n      }\n    }\n  }\n  // Diff took too long and hit the deadline or\n  // number of diffs equals number of characters, no commonality at all.\n  return [new diff_match_patch.Diff(DIFF_DELETE, text1),\n          new diff_match_patch.Diff(DIFF_INSERT, text2)];\n};\n\n\n/**\n * Given the location of the 'middle snake', split the diff in two parts\n * and recurse.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} x Index of split point in text1.\n * @param {number} y Index of split point in text2.\n * @param {number} deadline Time at which to bail if not yet complete.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_bisectSplit_ = function(text1, text2, x, y,\n    deadline) {\n  var text1a = text1.substring(0, x);\n  var text2a = text2.substring(0, y);\n  var text1b = text1.substring(x);\n  var text2b = text2.substring(y);\n\n  // Compute both diffs serially.\n  var diffs = this.diff_main(text1a, text2a, false, deadline);\n  var diffsb = this.diff_main(text1b, text2b, false, deadline);\n\n  return diffs.concat(diffsb);\n};\n\n\n/**\n * Split two texts into an array of strings.  Reduce the texts to a string of\n * hashes where each Unicode character represents one line.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}\n *     An object containing the encoded text1, the encoded text2 and\n *     the array of unique strings.\n *     The zeroth element of the array of unique strings is intentionally blank.\n * @private\n */\ndiff_match_patch.prototype.diff_linesToChars_ = function(text1, text2) {\n  var lineArray = [];  // e.g. lineArray[4] == 'Hello\\n'\n  var lineHash = {};   // e.g. lineHash['Hello\\n'] == 4\n\n  // '\\x00' is a valid character, but various debuggers don't like it.\n  // So we'll insert a junk entry to avoid generating a null character.\n  lineArray[0] = '';\n\n  /**\n   * Split a text into an array of strings.  Reduce the texts to a string of\n   * hashes where each Unicode character represents one line.\n   * Modifies linearray and linehash through being a closure.\n   * @param {string} text String to encode.\n   * @return {string} Encoded string.\n   * @private\n   */\n  function diff_linesToCharsMunge_(text) {\n    var chars = '';\n    // Walk the text, pulling out a substring for each line.\n    // text.split('\\n') would would temporarily double our memory footprint.\n    // Modifying text would create many large strings to garbage collect.\n    var lineStart = 0;\n    var lineEnd = -1;\n    // Keeping our own length variable is faster than looking it up.\n    var lineArrayLength = lineArray.length;\n    while (lineEnd < text.length - 1) {\n      lineEnd = text.indexOf('\\n', lineStart);\n      if (lineEnd == -1) {\n        lineEnd = text.length - 1;\n      }\n      var line = text.substring(lineStart, lineEnd + 1);\n\n      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) :\n          (lineHash[line] !== undefined)) {\n        chars += String.fromCharCode(lineHash[line]);\n      } else {\n        if (lineArrayLength == maxLines) {\n          // Bail out at 65535 because\n          // String.fromCharCode(65536) == String.fromCharCode(0)\n          line = text.substring(lineStart);\n          lineEnd = text.length;\n        }\n        chars += String.fromCharCode(lineArrayLength);\n        lineHash[line] = lineArrayLength;\n        lineArray[lineArrayLength++] = line;\n      }\n      lineStart = lineEnd + 1;\n    }\n    return chars;\n  }\n  // Allocate 2/3rds of the space for text1, the rest for text2.\n  var maxLines = 40000;\n  var chars1 = diff_linesToCharsMunge_(text1);\n  maxLines = 65535;\n  var chars2 = diff_linesToCharsMunge_(text2);\n  return {chars1: chars1, chars2: chars2, lineArray: lineArray};\n};\n\n\n/**\n * Rehydrate the text in a diff from a string of line hashes to real lines of\n * text.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @param {!Array.<string>} lineArray Array of unique strings.\n * @private\n */\ndiff_match_patch.prototype.diff_charsToLines_ = function(diffs, lineArray) {\n  for (var i = 0; i < diffs.length; i++) {\n    var chars = diffs[i][1];\n    var text = [];\n    for (var j = 0; j < chars.length; j++) {\n      text[j] = lineArray[chars.charCodeAt(j)];\n    }\n    diffs[i][1] = text.join('');\n  }\n};\n\n\n/**\n * Determine the common prefix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the start of each\n *     string.\n */\ndiff_match_patch.prototype.diff_commonPrefix = function(text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {\n    return 0;\n  }\n  // Binary search.\n  // Performance analysis: https://neil.fraser.name/news/2007/10/09/\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerstart = 0;\n  while (pointermin < pointermid) {\n    if (text1.substring(pointerstart, pointermid) ==\n        text2.substring(pointerstart, pointermid)) {\n      pointermin = pointermid;\n      pointerstart = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n  return pointermid;\n};\n\n\n/**\n * Determine the common suffix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of each string.\n */\ndiff_match_patch.prototype.diff_commonSuffix = function(text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 ||\n      text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {\n    return 0;\n  }\n  // Binary search.\n  // Performance analysis: https://neil.fraser.name/news/2007/10/09/\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerend = 0;\n  while (pointermin < pointermid) {\n    if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==\n        text2.substring(text2.length - pointermid, text2.length - pointerend)) {\n      pointermin = pointermid;\n      pointerend = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n  return pointermid;\n};\n\n\n/**\n * Determine if the suffix of one string is the prefix of another.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of the first\n *     string and the start of the second string.\n * @private\n */\ndiff_match_patch.prototype.diff_commonOverlap_ = function(text1, text2) {\n  // Cache the text lengths to prevent multiple calls.\n  var text1_length = text1.length;\n  var text2_length = text2.length;\n  // Eliminate the null case.\n  if (text1_length == 0 || text2_length == 0) {\n    return 0;\n  }\n  // Truncate the longer string.\n  if (text1_length > text2_length) {\n    text1 = text1.substring(text1_length - text2_length);\n  } else if (text1_length < text2_length) {\n    text2 = text2.substring(0, text1_length);\n  }\n  var text_length = Math.min(text1_length, text2_length);\n  // Quick check for the worst case.\n  if (text1 == text2) {\n    return text_length;\n  }\n\n  // Start by looking for a single character match\n  // and increase length until no match is found.\n  // Performance analysis: https://neil.fraser.name/news/2010/11/04/\n  var best = 0;\n  var length = 1;\n  while (true) {\n    var pattern = text1.substring(text_length - length);\n    var found = text2.indexOf(pattern);\n    if (found == -1) {\n      return best;\n    }\n    length += found;\n    if (found == 0 || text1.substring(text_length - length) ==\n        text2.substring(0, length)) {\n      best = length;\n      length++;\n    }\n  }\n};\n\n\n/**\n * Do the two texts share a substring which is at least half the length of the\n * longer text?\n * This speedup can produce non-minimal diffs.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {Array.<string>} Five element Array, containing the prefix of\n *     text1, the suffix of text1, the prefix of text2, the suffix of\n *     text2 and the common middle.  Or null if there was no match.\n * @private\n */\ndiff_match_patch.prototype.diff_halfMatch_ = function(text1, text2) {\n  if (this.Diff_Timeout <= 0) {\n    // Don't risk returning a non-optimal diff if we have unlimited time.\n    return null;\n  }\n  var longtext = text1.length > text2.length ? text1 : text2;\n  var shorttext = text1.length > text2.length ? text2 : text1;\n  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {\n    return null;  // Pointless.\n  }\n  var dmp = this;  // 'this' becomes 'window' in a closure.\n\n  /**\n   * Does a substring of shorttext exist within longtext such that the substring\n   * is at least half the length of longtext?\n   * Closure, but does not reference any external variables.\n   * @param {string} longtext Longer string.\n   * @param {string} shorttext Shorter string.\n   * @param {number} i Start index of quarter length substring within longtext.\n   * @return {Array.<string>} Five element Array, containing the prefix of\n   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n   *     of shorttext and the common middle.  Or null if there was no match.\n   * @private\n   */\n  function diff_halfMatchI_(longtext, shorttext, i) {\n    // Start with a 1/4 length substring at position i as a seed.\n    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));\n    var j = -1;\n    var best_common = '';\n    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;\n    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {\n      var prefixLength = dmp.diff_commonPrefix(longtext.substring(i),\n                                               shorttext.substring(j));\n      var suffixLength = dmp.diff_commonSuffix(longtext.substring(0, i),\n                                               shorttext.substring(0, j));\n      if (best_common.length < suffixLength + prefixLength) {\n        best_common = shorttext.substring(j - suffixLength, j) +\n            shorttext.substring(j, j + prefixLength);\n        best_longtext_a = longtext.substring(0, i - suffixLength);\n        best_longtext_b = longtext.substring(i + prefixLength);\n        best_shorttext_a = shorttext.substring(0, j - suffixLength);\n        best_shorttext_b = shorttext.substring(j + prefixLength);\n      }\n    }\n    if (best_common.length * 2 >= longtext.length) {\n      return [best_longtext_a, best_longtext_b,\n              best_shorttext_a, best_shorttext_b, best_common];\n    } else {\n      return null;\n    }\n  }\n\n  // First check if the second quarter is the seed for a half-match.\n  var hm1 = diff_halfMatchI_(longtext, shorttext,\n                             Math.ceil(longtext.length / 4));\n  // Check again based on the third quarter.\n  var hm2 = diff_halfMatchI_(longtext, shorttext,\n                             Math.ceil(longtext.length / 2));\n  var hm;\n  if (!hm1 && !hm2) {\n    return null;\n  } else if (!hm2) {\n    hm = hm1;\n  } else if (!hm1) {\n    hm = hm2;\n  } else {\n    // Both matched.  Select the longest.\n    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;\n  }\n\n  // A half-match was found, sort out the return data.\n  var text1_a, text1_b, text2_a, text2_b;\n  if (text1.length > text2.length) {\n    text1_a = hm[0];\n    text1_b = hm[1];\n    text2_a = hm[2];\n    text2_b = hm[3];\n  } else {\n    text2_a = hm[0];\n    text2_b = hm[1];\n    text1_a = hm[2];\n    text1_b = hm[3];\n  }\n  var mid_common = hm[4];\n  return [text1_a, text1_b, text2_a, text2_b, mid_common];\n};\n\n\n/**\n * Reduce the number of edits by eliminating semantically trivial equalities.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {\n  var changes = false;\n  var equalities = [];  // Stack of indices where equalities are found.\n  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.\n  /** @type {?string} */\n  var lastEquality = null;\n  // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n  var pointer = 0;  // Index of current position.\n  // Number of characters that changed prior to the equality.\n  var length_insertions1 = 0;\n  var length_deletions1 = 0;\n  // Number of characters that changed after the equality.\n  var length_insertions2 = 0;\n  var length_deletions2 = 0;\n  while (pointer < diffs.length) {\n    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.\n      equalities[equalitiesLength++] = pointer;\n      length_insertions1 = length_insertions2;\n      length_deletions1 = length_deletions2;\n      length_insertions2 = 0;\n      length_deletions2 = 0;\n      lastEquality = diffs[pointer][1];\n    } else {  // An insertion or deletion.\n      if (diffs[pointer][0] == DIFF_INSERT) {\n        length_insertions2 += diffs[pointer][1].length;\n      } else {\n        length_deletions2 += diffs[pointer][1].length;\n      }\n      // Eliminate an equality that is smaller or equal to the edits on both\n      // sides of it.\n      if (lastEquality && (lastEquality.length <=\n          Math.max(length_insertions1, length_deletions1)) &&\n          (lastEquality.length <= Math.max(length_insertions2,\n                                           length_deletions2))) {\n        // Duplicate record.\n        diffs.splice(equalities[equalitiesLength - 1], 0,\n                     new diff_match_patch.Diff(DIFF_DELETE, lastEquality));\n        // Change second copy to insert.\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n        // Throw away the equality we just deleted.\n        equalitiesLength--;\n        // Throw away the previous equality (it needs to be reevaluated).\n        equalitiesLength--;\n        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\n        length_insertions1 = 0;  // Reset the counters.\n        length_deletions1 = 0;\n        length_insertions2 = 0;\n        length_deletions2 = 0;\n        lastEquality = null;\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n\n  // Normalize the diff.\n  if (changes) {\n    this.diff_cleanupMerge(diffs);\n  }\n  this.diff_cleanupSemanticLossless(diffs);\n\n  // Find any overlaps between deletions and insertions.\n  // e.g: <del>abcxxx</del><ins>xxxdef</ins>\n  //   -> <del>abc</del>xxx<ins>def</ins>\n  // e.g: <del>xxxabc</del><ins>defxxx</ins>\n  //   -> <ins>def</ins>xxx<del>abc</del>\n  // Only extract an overlap if it is as big as the edit ahead or behind it.\n  pointer = 1;\n  while (pointer < diffs.length) {\n    if (diffs[pointer - 1][0] == DIFF_DELETE &&\n        diffs[pointer][0] == DIFF_INSERT) {\n      var deletion = diffs[pointer - 1][1];\n      var insertion = diffs[pointer][1];\n      var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);\n      var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);\n      if (overlap_length1 >= overlap_length2) {\n        if (overlap_length1 >= deletion.length / 2 ||\n            overlap_length1 >= insertion.length / 2) {\n          // Overlap found.  Insert an equality and trim the surrounding edits.\n          diffs.splice(pointer, 0, new diff_match_patch.Diff(DIFF_EQUAL,\n              insertion.substring(0, overlap_length1)));\n          diffs[pointer - 1][1] =\n              deletion.substring(0, deletion.length - overlap_length1);\n          diffs[pointer + 1][1] = insertion.substring(overlap_length1);\n          pointer++;\n        }\n      } else {\n        if (overlap_length2 >= deletion.length / 2 ||\n            overlap_length2 >= insertion.length / 2) {\n          // Reverse overlap found.\n          // Insert an equality and swap and trim the surrounding edits.\n          diffs.splice(pointer, 0, new diff_match_patch.Diff(DIFF_EQUAL,\n              deletion.substring(0, overlap_length2)));\n          diffs[pointer - 1][0] = DIFF_INSERT;\n          diffs[pointer - 1][1] =\n              insertion.substring(0, insertion.length - overlap_length2);\n          diffs[pointer + 1][0] = DIFF_DELETE;\n          diffs[pointer + 1][1] =\n              deletion.substring(overlap_length2);\n          pointer++;\n        }\n      }\n      pointer++;\n    }\n    pointer++;\n  }\n};\n\n\n/**\n * Look for single edits surrounded on both sides by equalities\n * which can be shifted sideways to align the edit to a word boundary.\n * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {\n  /**\n   * Given two strings, compute a score representing whether the internal\n   * boundary falls on logical boundaries.\n   * Scores range from 6 (best) to 0 (worst).\n   * Closure, but does not reference any external variables.\n   * @param {string} one First string.\n   * @param {string} two Second string.\n   * @return {number} The score.\n   * @private\n   */\n  function diff_cleanupSemanticScore_(one, two) {\n    if (!one || !two) {\n      // Edges are the best.\n      return 6;\n    }\n\n    // Each port of this function behaves slightly differently due to\n    // subtle differences in each language's definition of things like\n    // 'whitespace'.  Since this function's purpose is largely cosmetic,\n    // the choice has been made to use each language's native features\n    // rather than force total conformity.\n    var char1 = one.charAt(one.length - 1);\n    var char2 = two.charAt(0);\n    var nonAlphaNumeric1 = char1.match(diff_match_patch.nonAlphaNumericRegex_);\n    var nonAlphaNumeric2 = char2.match(diff_match_patch.nonAlphaNumericRegex_);\n    var whitespace1 = nonAlphaNumeric1 &&\n        char1.match(diff_match_patch.whitespaceRegex_);\n    var whitespace2 = nonAlphaNumeric2 &&\n        char2.match(diff_match_patch.whitespaceRegex_);\n    var lineBreak1 = whitespace1 &&\n        char1.match(diff_match_patch.linebreakRegex_);\n    var lineBreak2 = whitespace2 &&\n        char2.match(diff_match_patch.linebreakRegex_);\n    var blankLine1 = lineBreak1 &&\n        one.match(diff_match_patch.blanklineEndRegex_);\n    var blankLine2 = lineBreak2 &&\n        two.match(diff_match_patch.blanklineStartRegex_);\n\n    if (blankLine1 || blankLine2) {\n      // Five points for blank lines.\n      return 5;\n    } else if (lineBreak1 || lineBreak2) {\n      // Four points for line breaks.\n      return 4;\n    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {\n      // Three points for end of sentences.\n      return 3;\n    } else if (whitespace1 || whitespace2) {\n      // Two points for whitespace.\n      return 2;\n    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {\n      // One point for non-alphanumeric.\n      return 1;\n    }\n    return 0;\n  }\n\n  var pointer = 1;\n  // Intentionally ignore the first and last element (don't need checking).\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] == DIFF_EQUAL &&\n        diffs[pointer + 1][0] == DIFF_EQUAL) {\n      // This is a single edit surrounded by equalities.\n      var equality1 = diffs[pointer - 1][1];\n      var edit = diffs[pointer][1];\n      var equality2 = diffs[pointer + 1][1];\n\n      // First, shift the edit as far left as possible.\n      var commonOffset = this.diff_commonSuffix(equality1, edit);\n      if (commonOffset) {\n        var commonString = edit.substring(edit.length - commonOffset);\n        equality1 = equality1.substring(0, equality1.length - commonOffset);\n        edit = commonString + edit.substring(0, edit.length - commonOffset);\n        equality2 = commonString + equality2;\n      }\n\n      // Second, step character by character right, looking for the best fit.\n      var bestEquality1 = equality1;\n      var bestEdit = edit;\n      var bestEquality2 = equality2;\n      var bestScore = diff_cleanupSemanticScore_(equality1, edit) +\n          diff_cleanupSemanticScore_(edit, equality2);\n      while (edit.charAt(0) === equality2.charAt(0)) {\n        equality1 += edit.charAt(0);\n        edit = edit.substring(1) + equality2.charAt(0);\n        equality2 = equality2.substring(1);\n        var score = diff_cleanupSemanticScore_(equality1, edit) +\n            diff_cleanupSemanticScore_(edit, equality2);\n        // The >= encourages trailing rather than leading whitespace on edits.\n        if (score >= bestScore) {\n          bestScore = score;\n          bestEquality1 = equality1;\n          bestEdit = edit;\n          bestEquality2 = equality2;\n        }\n      }\n\n      if (diffs[pointer - 1][1] != bestEquality1) {\n        // We have an improvement, save it back to the diff.\n        if (bestEquality1) {\n          diffs[pointer - 1][1] = bestEquality1;\n        } else {\n          diffs.splice(pointer - 1, 1);\n          pointer--;\n        }\n        diffs[pointer][1] = bestEdit;\n        if (bestEquality2) {\n          diffs[pointer + 1][1] = bestEquality2;\n        } else {\n          diffs.splice(pointer + 1, 1);\n          pointer--;\n        }\n      }\n    }\n    pointer++;\n  }\n};\n\n// Define some regex patterns for matching boundaries.\ndiff_match_patch.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;\ndiff_match_patch.whitespaceRegex_ = /\\s/;\ndiff_match_patch.linebreakRegex_ = /[\\r\\n]/;\ndiff_match_patch.blanklineEndRegex_ = /\\n\\r?\\n$/;\ndiff_match_patch.blanklineStartRegex_ = /^\\r?\\n\\r?\\n/;\n\n/**\n * Reduce the number of edits by eliminating operationally trivial equalities.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {\n  var changes = false;\n  var equalities = [];  // Stack of indices where equalities are found.\n  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.\n  /** @type {?string} */\n  var lastEquality = null;\n  // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n  var pointer = 0;  // Index of current position.\n  // Is there an insertion operation before the last equality.\n  var pre_ins = false;\n  // Is there a deletion operation before the last equality.\n  var pre_del = false;\n  // Is there an insertion operation after the last equality.\n  var post_ins = false;\n  // Is there a deletion operation after the last equality.\n  var post_del = false;\n  while (pointer < diffs.length) {\n    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.\n      if (diffs[pointer][1].length < this.Diff_EditCost &&\n          (post_ins || post_del)) {\n        // Candidate found.\n        equalities[equalitiesLength++] = pointer;\n        pre_ins = post_ins;\n        pre_del = post_del;\n        lastEquality = diffs[pointer][1];\n      } else {\n        // Not a candidate, and can never become one.\n        equalitiesLength = 0;\n        lastEquality = null;\n      }\n      post_ins = post_del = false;\n    } else {  // An insertion or deletion.\n      if (diffs[pointer][0] == DIFF_DELETE) {\n        post_del = true;\n      } else {\n        post_ins = true;\n      }\n      /*\n       * Five types to be split:\n       * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n       * <ins>A</ins>X<ins>C</ins><del>D</del>\n       * <ins>A</ins><del>B</del>X<ins>C</ins>\n       * <ins>A</del>X<ins>C</ins><del>D</del>\n       * <ins>A</ins><del>B</del>X<del>C</del>\n       */\n      if (lastEquality && ((pre_ins && pre_del && post_ins && post_del) ||\n                           ((lastEquality.length < this.Diff_EditCost / 2) &&\n                            (pre_ins + pre_del + post_ins + post_del) == 3))) {\n        // Duplicate record.\n        diffs.splice(equalities[equalitiesLength - 1], 0,\n                     new diff_match_patch.Diff(DIFF_DELETE, lastEquality));\n        // Change second copy to insert.\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n        equalitiesLength--;  // Throw away the equality we just deleted;\n        lastEquality = null;\n        if (pre_ins && pre_del) {\n          // No changes made which could affect previous entry, keep going.\n          post_ins = post_del = true;\n          equalitiesLength = 0;\n        } else {\n          equalitiesLength--;  // Throw away the previous equality.\n          pointer = equalitiesLength > 0 ?\n              equalities[equalitiesLength - 1] : -1;\n          post_ins = post_del = false;\n        }\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n\n  if (changes) {\n    this.diff_cleanupMerge(diffs);\n  }\n};\n\n\n/**\n * Reorder and merge like edit sections.  Merge equalities.\n * Any edit section can move as long as it doesn't cross an equality.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupMerge = function(diffs) {\n  // Add a dummy entry at the end.\n  diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, ''));\n  var pointer = 0;\n  var count_delete = 0;\n  var count_insert = 0;\n  var text_delete = '';\n  var text_insert = '';\n  var commonlength;\n  while (pointer < diffs.length) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        count_insert++;\n        text_insert += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_DELETE:\n        count_delete++;\n        text_delete += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_EQUAL:\n        // Upon reaching an equality, check for prior redundancies.\n        if (count_delete + count_insert > 1) {\n          if (count_delete !== 0 && count_insert !== 0) {\n            // Factor out any common prefixies.\n            commonlength = this.diff_commonPrefix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              if ((pointer - count_delete - count_insert) > 0 &&\n                  diffs[pointer - count_delete - count_insert - 1][0] ==\n                  DIFF_EQUAL) {\n                diffs[pointer - count_delete - count_insert - 1][1] +=\n                    text_insert.substring(0, commonlength);\n              } else {\n                diffs.splice(0, 0, new diff_match_patch.Diff(DIFF_EQUAL,\n                    text_insert.substring(0, commonlength)));\n                pointer++;\n              }\n              text_insert = text_insert.substring(commonlength);\n              text_delete = text_delete.substring(commonlength);\n            }\n            // Factor out any common suffixies.\n            commonlength = this.diff_commonSuffix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              diffs[pointer][1] = text_insert.substring(text_insert.length -\n                  commonlength) + diffs[pointer][1];\n              text_insert = text_insert.substring(0, text_insert.length -\n                  commonlength);\n              text_delete = text_delete.substring(0, text_delete.length -\n                  commonlength);\n            }\n          }\n          // Delete the offending records and add the merged ones.\n          pointer -= count_delete + count_insert;\n          diffs.splice(pointer, count_delete + count_insert);\n          if (text_delete.length) {\n            diffs.splice(pointer, 0,\n                new diff_match_patch.Diff(DIFF_DELETE, text_delete));\n            pointer++;\n          }\n          if (text_insert.length) {\n            diffs.splice(pointer, 0,\n                new diff_match_patch.Diff(DIFF_INSERT, text_insert));\n            pointer++;\n          }\n          pointer++;\n        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {\n          // Merge this equality with the previous one.\n          diffs[pointer - 1][1] += diffs[pointer][1];\n          diffs.splice(pointer, 1);\n        } else {\n          pointer++;\n        }\n        count_insert = 0;\n        count_delete = 0;\n        text_delete = '';\n        text_insert = '';\n        break;\n    }\n  }\n  if (diffs[diffs.length - 1][1] === '') {\n    diffs.pop();  // Remove the dummy entry at the end.\n  }\n\n  // Second pass: look for single edits surrounded on both sides by equalities\n  // which can be shifted sideways to eliminate an equality.\n  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n  var changes = false;\n  pointer = 1;\n  // Intentionally ignore the first and last element (don't need checking).\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] == DIFF_EQUAL &&\n        diffs[pointer + 1][0] == DIFF_EQUAL) {\n      // This is a single edit surrounded by equalities.\n      if (diffs[pointer][1].substring(diffs[pointer][1].length -\n          diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {\n        // Shift the edit over the previous equality.\n        diffs[pointer][1] = diffs[pointer - 1][1] +\n            diffs[pointer][1].substring(0, diffs[pointer][1].length -\n                                        diffs[pointer - 1][1].length);\n        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\n        diffs.splice(pointer - 1, 1);\n        changes = true;\n      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==\n          diffs[pointer + 1][1]) {\n        // Shift the edit over the next equality.\n        diffs[pointer - 1][1] += diffs[pointer + 1][1];\n        diffs[pointer][1] =\n            diffs[pointer][1].substring(diffs[pointer + 1][1].length) +\n            diffs[pointer + 1][1];\n        diffs.splice(pointer + 1, 1);\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n  // If shifts were made, the diff needs reordering and another shift sweep.\n  if (changes) {\n    this.diff_cleanupMerge(diffs);\n  }\n};\n\n\n/**\n * loc is a location in text1, compute and return the equivalent location in\n * text2.\n * e.g. 'The cat' vs 'The big cat', 1->1, 5->8\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @param {number} loc Location within text1.\n * @return {number} Location within text2.\n */\ndiff_match_patch.prototype.diff_xIndex = function(diffs, loc) {\n  var chars1 = 0;\n  var chars2 = 0;\n  var last_chars1 = 0;\n  var last_chars2 = 0;\n  var x;\n  for (x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_INSERT) {  // Equality or deletion.\n      chars1 += diffs[x][1].length;\n    }\n    if (diffs[x][0] !== DIFF_DELETE) {  // Equality or insertion.\n      chars2 += diffs[x][1].length;\n    }\n    if (chars1 > loc) {  // Overshot the location.\n      break;\n    }\n    last_chars1 = chars1;\n    last_chars2 = chars2;\n  }\n  // Was the location was deleted?\n  if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {\n    return last_chars2;\n  }\n  // Add the remaining character length.\n  return last_chars2 + (loc - last_chars1);\n};\n\n\n/**\n * Convert a diff array into a pretty HTML report.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} HTML representation.\n */\ndiff_match_patch.prototype.diff_prettyHtml = function(diffs) {\n  var html = [];\n  var pattern_amp = /&/g;\n  var pattern_lt = /</g;\n  var pattern_gt = />/g;\n  var pattern_para = /\\n/g;\n  for (var x = 0; x < diffs.length; x++) {\n    var op = diffs[x][0];    // Operation (insert, delete, equal)\n    var data = diffs[x][1];  // Text of change.\n    var text = data.replace(pattern_amp, '&amp;').replace(pattern_lt, '&lt;')\n        .replace(pattern_gt, '&gt;').replace(pattern_para, '&para;<br>');\n    switch (op) {\n      case DIFF_INSERT:\n        html[x] = '<ins style=\"background:#e6ffe6;\">' + text + '</ins>';\n        break;\n      case DIFF_DELETE:\n        html[x] = '<del style=\"background:#ffe6e6;\">' + text + '</del>';\n        break;\n      case DIFF_EQUAL:\n        html[x] = '<span>' + text + '</span>';\n        break;\n    }\n  }\n  return html.join('');\n};\n\n\n/**\n * Compute and return the source text (all equalities and deletions).\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} Source text.\n */\ndiff_match_patch.prototype.diff_text1 = function(diffs) {\n  var text = [];\n  for (var x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_INSERT) {\n      text[x] = diffs[x][1];\n    }\n  }\n  return text.join('');\n};\n\n\n/**\n * Compute and return the destination text (all equalities and insertions).\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} Destination text.\n */\ndiff_match_patch.prototype.diff_text2 = function(diffs) {\n  var text = [];\n  for (var x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_DELETE) {\n      text[x] = diffs[x][1];\n    }\n  }\n  return text.join('');\n};\n\n\n/**\n * Compute the Levenshtein distance; the number of inserted, deleted or\n * substituted characters.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {number} Number of changes.\n */\ndiff_match_patch.prototype.diff_levenshtein = function(diffs) {\n  var levenshtein = 0;\n  var insertions = 0;\n  var deletions = 0;\n  for (var x = 0; x < diffs.length; x++) {\n    var op = diffs[x][0];\n    var data = diffs[x][1];\n    switch (op) {\n      case DIFF_INSERT:\n        insertions += data.length;\n        break;\n      case DIFF_DELETE:\n        deletions += data.length;\n        break;\n      case DIFF_EQUAL:\n        // A deletion and an insertion is one substitution.\n        levenshtein += Math.max(insertions, deletions);\n        insertions = 0;\n        deletions = 0;\n        break;\n    }\n  }\n  levenshtein += Math.max(insertions, deletions);\n  return levenshtein;\n};\n\n\n/**\n * Crush the diff into an encoded string which describes the operations\n * required to transform text1 into text2.\n * E.g. =3\\t-2\\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.\n * Operations are tab-separated.  Inserted text is escaped using %xx notation.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} Delta text.\n */\ndiff_match_patch.prototype.diff_toDelta = function(diffs) {\n  var text = [];\n  for (var x = 0; x < diffs.length; x++) {\n    switch (diffs[x][0]) {\n      case DIFF_INSERT:\n        text[x] = '+' + encodeURI(diffs[x][1]);\n        break;\n      case DIFF_DELETE:\n        text[x] = '-' + diffs[x][1].length;\n        break;\n      case DIFF_EQUAL:\n        text[x] = '=' + diffs[x][1].length;\n        break;\n    }\n  }\n  return text.join('\\t').replace(/%20/g, ' ');\n};\n\n\n/**\n * Given the original text1, and an encoded string which describes the\n * operations required to transform text1 into text2, compute the full diff.\n * @param {string} text1 Source string for the diff.\n * @param {string} delta Delta text.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @throws {!Error} If invalid input.\n */\ndiff_match_patch.prototype.diff_fromDelta = function(text1, delta) {\n  var diffs = [];\n  var diffsLength = 0;  // Keeping our own length var is faster in JS.\n  var pointer = 0;  // Cursor in text1\n  var tokens = delta.split(/\\t/g);\n  for (var x = 0; x < tokens.length; x++) {\n    // Each token begins with a one character parameter which specifies the\n    // operation of this token (delete, insert, equality).\n    var param = tokens[x].substring(1);\n    switch (tokens[x].charAt(0)) {\n      case '+':\n        try {\n          diffs[diffsLength++] =\n              new diff_match_patch.Diff(DIFF_INSERT, decodeURI(param));\n        } catch (ex) {\n          // Malformed URI sequence.\n          throw new Error('Illegal escape in diff_fromDelta: ' + param);\n        }\n        break;\n      case '-':\n        // Fall through.\n      case '=':\n        var n = parseInt(param, 10);\n        if (isNaN(n) || n < 0) {\n          throw new Error('Invalid number in diff_fromDelta: ' + param);\n        }\n        var text = text1.substring(pointer, pointer += n);\n        if (tokens[x].charAt(0) == '=') {\n          diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_EQUAL, text);\n        } else {\n          diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_DELETE, text);\n        }\n        break;\n      default:\n        // Blank tokens are ok (from a trailing \\t).\n        // Anything else is an error.\n        if (tokens[x]) {\n          throw new Error('Invalid diff operation in diff_fromDelta: ' +\n                          tokens[x]);\n        }\n    }\n  }\n  if (pointer != text1.length) {\n    throw new Error('Delta length (' + pointer +\n        ') does not equal source text length (' + text1.length + ').');\n  }\n  return diffs;\n};\n\n\n//  MATCH FUNCTIONS\n\n\n/**\n * Locate the best instance of 'pattern' in 'text' near 'loc'.\n * @param {string} text The text to search.\n * @param {string} pattern The pattern to search for.\n * @param {number} loc The location to search around.\n * @return {number} Best match index or -1.\n */\ndiff_match_patch.prototype.match_main = function(text, pattern, loc) {\n  // Check for null inputs.\n  if (text == null || pattern == null || loc == null) {\n    throw new Error('Null input. (match_main)');\n  }\n\n  loc = Math.max(0, Math.min(loc, text.length));\n  if (text == pattern) {\n    // Shortcut (potentially not guaranteed by the algorithm)\n    return 0;\n  } else if (!text.length) {\n    // Nothing to match.\n    return -1;\n  } else if (text.substring(loc, loc + pattern.length) == pattern) {\n    // Perfect match at the perfect spot!  (Includes case of null pattern)\n    return loc;\n  } else {\n    // Do a fuzzy compare.\n    return this.match_bitap_(text, pattern, loc);\n  }\n};\n\n\n/**\n * Locate the best instance of 'pattern' in 'text' near 'loc' using the\n * Bitap algorithm.\n * @param {string} text The text to search.\n * @param {string} pattern The pattern to search for.\n * @param {number} loc The location to search around.\n * @return {number} Best match index or -1.\n * @private\n */\ndiff_match_patch.prototype.match_bitap_ = function(text, pattern, loc) {\n  if (pattern.length > this.Match_MaxBits) {\n    throw new Error('Pattern too long for this browser.');\n  }\n\n  // Initialise the alphabet.\n  var s = this.match_alphabet_(pattern);\n\n  var dmp = this;  // 'this' becomes 'window' in a closure.\n\n  /**\n   * Compute and return the score for a match with e errors and x location.\n   * Accesses loc and pattern through being a closure.\n   * @param {number} e Number of errors in match.\n   * @param {number} x Location of match.\n   * @return {number} Overall score for match (0.0 = good, 1.0 = bad).\n   * @private\n   */\n  function match_bitapScore_(e, x) {\n    var accuracy = e / pattern.length;\n    var proximity = Math.abs(loc - x);\n    if (!dmp.Match_Distance) {\n      // Dodge divide by zero error.\n      return proximity ? 1.0 : accuracy;\n    }\n    return accuracy + (proximity / dmp.Match_Distance);\n  }\n\n  // Highest score beyond which we give up.\n  var score_threshold = this.Match_Threshold;\n  // Is there a nearby exact match? (speedup)\n  var best_loc = text.indexOf(pattern, loc);\n  if (best_loc != -1) {\n    score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);\n    // What about in the other direction? (speedup)\n    best_loc = text.lastIndexOf(pattern, loc + pattern.length);\n    if (best_loc != -1) {\n      score_threshold =\n          Math.min(match_bitapScore_(0, best_loc), score_threshold);\n    }\n  }\n\n  // Initialise the bit arrays.\n  var matchmask = 1 << (pattern.length - 1);\n  best_loc = -1;\n\n  var bin_min, bin_mid;\n  var bin_max = pattern.length + text.length;\n  var last_rd;\n  for (var d = 0; d < pattern.length; d++) {\n    // Scan for the best match; each iteration allows for one more error.\n    // Run a binary search to determine how far from 'loc' we can stray at this\n    // error level.\n    bin_min = 0;\n    bin_mid = bin_max;\n    while (bin_min < bin_mid) {\n      if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {\n        bin_min = bin_mid;\n      } else {\n        bin_max = bin_mid;\n      }\n      bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);\n    }\n    // Use the result from this iteration as the maximum for the next.\n    bin_max = bin_mid;\n    var start = Math.max(1, loc - bin_mid + 1);\n    var finish = Math.min(loc + bin_mid, text.length) + pattern.length;\n\n    var rd = Array(finish + 2);\n    rd[finish + 1] = (1 << d) - 1;\n    for (var j = finish; j >= start; j--) {\n      // The alphabet (s) is a sparse hash, so the following line generates\n      // warnings.\n      var charMatch = s[text.charAt(j - 1)];\n      if (d === 0) {  // First pass: exact match.\n        rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;\n      } else {  // Subsequent passes: fuzzy match.\n        rd[j] = (((rd[j + 1] << 1) | 1) & charMatch) |\n                (((last_rd[j + 1] | last_rd[j]) << 1) | 1) |\n                last_rd[j + 1];\n      }\n      if (rd[j] & matchmask) {\n        var score = match_bitapScore_(d, j - 1);\n        // This match will almost certainly be better than any existing match.\n        // But check anyway.\n        if (score <= score_threshold) {\n          // Told you so.\n          score_threshold = score;\n          best_loc = j - 1;\n          if (best_loc > loc) {\n            // When passing loc, don't exceed our current distance from loc.\n            start = Math.max(1, 2 * loc - best_loc);\n          } else {\n            // Already passed loc, downhill from here on in.\n            break;\n          }\n        }\n      }\n    }\n    // No hope for a (better) match at greater error levels.\n    if (match_bitapScore_(d + 1, loc) > score_threshold) {\n      break;\n    }\n    last_rd = rd;\n  }\n  return best_loc;\n};\n\n\n/**\n * Initialise the alphabet for the Bitap algorithm.\n * @param {string} pattern The text to encode.\n * @return {!Object} Hash of character locations.\n * @private\n */\ndiff_match_patch.prototype.match_alphabet_ = function(pattern) {\n  var s = {};\n  for (var i = 0; i < pattern.length; i++) {\n    s[pattern.charAt(i)] = 0;\n  }\n  for (var i = 0; i < pattern.length; i++) {\n    s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1);\n  }\n  return s;\n};\n\n\n//  PATCH FUNCTIONS\n\n\n/**\n * Increase the context until it is unique,\n * but don't let the pattern expand beyond Match_MaxBits.\n * @param {!diff_match_patch.patch_obj} patch The patch to grow.\n * @param {string} text Source text.\n * @private\n */\ndiff_match_patch.prototype.patch_addContext_ = function(patch, text) {\n  if (text.length == 0) {\n    return;\n  }\n  if (patch.start2 === null) {\n    throw Error('patch not initialized');\n  }\n  var pattern = text.substring(patch.start2, patch.start2 + patch.length1);\n  var padding = 0;\n\n  // Look for the first and last matches of pattern in text.  If two different\n  // matches are found, increase the pattern length.\n  while (text.indexOf(pattern) != text.lastIndexOf(pattern) &&\n         pattern.length < this.Match_MaxBits - this.Patch_Margin -\n         this.Patch_Margin) {\n    padding += this.Patch_Margin;\n    pattern = text.substring(patch.start2 - padding,\n                             patch.start2 + patch.length1 + padding);\n  }\n  // Add one chunk for good luck.\n  padding += this.Patch_Margin;\n\n  // Add the prefix.\n  var prefix = text.substring(patch.start2 - padding, patch.start2);\n  if (prefix) {\n    patch.diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, prefix));\n  }\n  // Add the suffix.\n  var suffix = text.substring(patch.start2 + patch.length1,\n                              patch.start2 + patch.length1 + padding);\n  if (suffix) {\n    patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, suffix));\n  }\n\n  // Roll back the start points.\n  patch.start1 -= prefix.length;\n  patch.start2 -= prefix.length;\n  // Extend the lengths.\n  patch.length1 += prefix.length + suffix.length;\n  patch.length2 += prefix.length + suffix.length;\n};\n\n\n/**\n * Compute a list of patches to turn text1 into text2.\n * Use diffs if provided, otherwise compute it ourselves.\n * There are four ways to call this function, depending on what data is\n * available to the caller:\n * Method 1:\n * a = text1, b = text2\n * Method 2:\n * a = diffs\n * Method 3 (optimal):\n * a = text1, b = diffs\n * Method 4 (deprecated, use method 3):\n * a = text1, b = text2, c = diffs\n *\n * @param {string|!Array.<!diff_match_patch.Diff>} a text1 (methods 1,3,4) or\n * Array of diff tuples for text1 to text2 (method 2).\n * @param {string|!Array.<!diff_match_patch.Diff>=} opt_b text2 (methods 1,4) or\n * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).\n * @param {string|!Array.<!diff_match_patch.Diff>=} opt_c Array of diff tuples\n * for text1 to text2 (method 4) or undefined (methods 1,2,3).\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\n */\ndiff_match_patch.prototype.patch_make = function(a, opt_b, opt_c) {\n  var text1, diffs;\n  if (typeof a == 'string' && typeof opt_b == 'string' &&\n      typeof opt_c == 'undefined') {\n    // Method 1: text1, text2\n    // Compute diffs from text1 and text2.\n    text1 = /** @type {string} */(a);\n    diffs = this.diff_main(text1, /** @type {string} */(opt_b), true);\n    if (diffs.length > 2) {\n      this.diff_cleanupSemantic(diffs);\n      this.diff_cleanupEfficiency(diffs);\n    }\n  } else if (a && typeof a == 'object' && typeof opt_b == 'undefined' &&\n      typeof opt_c == 'undefined') {\n    // Method 2: diffs\n    // Compute text1 from diffs.\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(a);\n    text1 = this.diff_text1(diffs);\n  } else if (typeof a == 'string' && opt_b && typeof opt_b == 'object' &&\n      typeof opt_c == 'undefined') {\n    // Method 3: text1, diffs\n    text1 = /** @type {string} */(a);\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_b);\n  } else if (typeof a == 'string' && typeof opt_b == 'string' &&\n      opt_c && typeof opt_c == 'object') {\n    // Method 4: text1, text2, diffs\n    // text2 is not used.\n    text1 = /** @type {string} */(a);\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_c);\n  } else {\n    throw new Error('Unknown call format to patch_make.');\n  }\n\n  if (diffs.length === 0) {\n    return [];  // Get rid of the null case.\n  }\n  var patches = [];\n  var patch = new diff_match_patch.patch_obj();\n  var patchDiffLength = 0;  // Keeping our own length var is faster in JS.\n  var char_count1 = 0;  // Number of characters into the text1 string.\n  var char_count2 = 0;  // Number of characters into the text2 string.\n  // Start with text1 (prepatch_text) and apply the diffs until we arrive at\n  // text2 (postpatch_text).  We recreate the patches one by one to determine\n  // context info.\n  var prepatch_text = text1;\n  var postpatch_text = text1;\n  for (var x = 0; x < diffs.length; x++) {\n    var diff_type = diffs[x][0];\n    var diff_text = diffs[x][1];\n\n    if (!patchDiffLength && diff_type !== DIFF_EQUAL) {\n      // A new patch starts here.\n      patch.start1 = char_count1;\n      patch.start2 = char_count2;\n    }\n\n    switch (diff_type) {\n      case DIFF_INSERT:\n        patch.diffs[patchDiffLength++] = diffs[x];\n        patch.length2 += diff_text.length;\n        postpatch_text = postpatch_text.substring(0, char_count2) + diff_text +\n                         postpatch_text.substring(char_count2);\n        break;\n      case DIFF_DELETE:\n        patch.length1 += diff_text.length;\n        patch.diffs[patchDiffLength++] = diffs[x];\n        postpatch_text = postpatch_text.substring(0, char_count2) +\n                         postpatch_text.substring(char_count2 +\n                             diff_text.length);\n        break;\n      case DIFF_EQUAL:\n        if (diff_text.length <= 2 * this.Patch_Margin &&\n            patchDiffLength && diffs.length != x + 1) {\n          // Small equality inside a patch.\n          patch.diffs[patchDiffLength++] = diffs[x];\n          patch.length1 += diff_text.length;\n          patch.length2 += diff_text.length;\n        } else if (diff_text.length >= 2 * this.Patch_Margin) {\n          // Time for a new patch.\n          if (patchDiffLength) {\n            this.patch_addContext_(patch, prepatch_text);\n            patches.push(patch);\n            patch = new diff_match_patch.patch_obj();\n            patchDiffLength = 0;\n            // Unlike Unidiff, our patch lists have a rolling context.\n            // https://github.com/google/diff-match-patch/wiki/Unidiff\n            // Update prepatch text & pos to reflect the application of the\n            // just completed patch.\n            prepatch_text = postpatch_text;\n            char_count1 = char_count2;\n          }\n        }\n        break;\n    }\n\n    // Update the current character count.\n    if (diff_type !== DIFF_INSERT) {\n      char_count1 += diff_text.length;\n    }\n    if (diff_type !== DIFF_DELETE) {\n      char_count2 += diff_text.length;\n    }\n  }\n  // Pick up the leftover patch if not empty.\n  if (patchDiffLength) {\n    this.patch_addContext_(patch, prepatch_text);\n    patches.push(patch);\n  }\n\n  return patches;\n};\n\n\n/**\n * Given an array of patches, return another array that is identical.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\n */\ndiff_match_patch.prototype.patch_deepCopy = function(patches) {\n  // Making deep copies is hard in JavaScript.\n  var patchesCopy = [];\n  for (var x = 0; x < patches.length; x++) {\n    var patch = patches[x];\n    var patchCopy = new diff_match_patch.patch_obj();\n    patchCopy.diffs = [];\n    for (var y = 0; y < patch.diffs.length; y++) {\n      patchCopy.diffs[y] =\n          new diff_match_patch.Diff(patch.diffs[y][0], patch.diffs[y][1]);\n    }\n    patchCopy.start1 = patch.start1;\n    patchCopy.start2 = patch.start2;\n    patchCopy.length1 = patch.length1;\n    patchCopy.length2 = patch.length2;\n    patchesCopy[x] = patchCopy;\n  }\n  return patchesCopy;\n};\n\n\n/**\n * Merge a set of patches onto the text.  Return a patched text, as well\n * as a list of true/false values indicating which patches were applied.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @param {string} text Old text.\n * @return {!Array.<string|!Array.<boolean>>} Two element Array, containing the\n *      new text and an array of boolean values.\n */\ndiff_match_patch.prototype.patch_apply = function(patches, text) {\n  if (patches.length == 0) {\n    return [text, []];\n  }\n\n  // Deep copy the patches so that no changes are made to originals.\n  patches = this.patch_deepCopy(patches);\n\n  var nullPadding = this.patch_addPadding(patches);\n  text = nullPadding + text + nullPadding;\n\n  this.patch_splitMax(patches);\n  // delta keeps track of the offset between the expected and actual location\n  // of the previous patch.  If there are patches expected at positions 10 and\n  // 20, but the first patch was found at 12, delta is 2 and the second patch\n  // has an effective expected position of 22.\n  var delta = 0;\n  var results = [];\n  for (var x = 0; x < patches.length; x++) {\n    var expected_loc = patches[x].start2 + delta;\n    var text1 = this.diff_text1(patches[x].diffs);\n    var start_loc;\n    var end_loc = -1;\n    if (text1.length > this.Match_MaxBits) {\n      // patch_splitMax will only provide an oversized pattern in the case of\n      // a monster delete.\n      start_loc = this.match_main(text, text1.substring(0, this.Match_MaxBits),\n                                  expected_loc);\n      if (start_loc != -1) {\n        end_loc = this.match_main(text,\n            text1.substring(text1.length - this.Match_MaxBits),\n            expected_loc + text1.length - this.Match_MaxBits);\n        if (end_loc == -1 || start_loc >= end_loc) {\n          // Can't find valid trailing context.  Drop this patch.\n          start_loc = -1;\n        }\n      }\n    } else {\n      start_loc = this.match_main(text, text1, expected_loc);\n    }\n    if (start_loc == -1) {\n      // No match found.  :(\n      results[x] = false;\n      // Subtract the delta for this failed patch from subsequent patches.\n      delta -= patches[x].length2 - patches[x].length1;\n    } else {\n      // Found a match.  :)\n      results[x] = true;\n      delta = start_loc - expected_loc;\n      var text2;\n      if (end_loc == -1) {\n        text2 = text.substring(start_loc, start_loc + text1.length);\n      } else {\n        text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);\n      }\n      if (text1 == text2) {\n        // Perfect match, just shove the replacement text in.\n        text = text.substring(0, start_loc) +\n               this.diff_text2(patches[x].diffs) +\n               text.substring(start_loc + text1.length);\n      } else {\n        // Imperfect match.  Run a diff to get a framework of equivalent\n        // indices.\n        var diffs = this.diff_main(text1, text2, false);\n        if (text1.length > this.Match_MaxBits &&\n            this.diff_levenshtein(diffs) / text1.length >\n            this.Patch_DeleteThreshold) {\n          // The end points match, but the content is unacceptably bad.\n          results[x] = false;\n        } else {\n          this.diff_cleanupSemanticLossless(diffs);\n          var index1 = 0;\n          var index2;\n          for (var y = 0; y < patches[x].diffs.length; y++) {\n            var mod = patches[x].diffs[y];\n            if (mod[0] !== DIFF_EQUAL) {\n              index2 = this.diff_xIndex(diffs, index1);\n            }\n            if (mod[0] === DIFF_INSERT) {  // Insertion\n              text = text.substring(0, start_loc + index2) + mod[1] +\n                     text.substring(start_loc + index2);\n            } else if (mod[0] === DIFF_DELETE) {  // Deletion\n              text = text.substring(0, start_loc + index2) +\n                     text.substring(start_loc + this.diff_xIndex(diffs,\n                         index1 + mod[1].length));\n            }\n            if (mod[0] !== DIFF_DELETE) {\n              index1 += mod[1].length;\n            }\n          }\n        }\n      }\n    }\n  }\n  // Strip the padding off.\n  text = text.substring(nullPadding.length, text.length - nullPadding.length);\n  return [text, results];\n};\n\n\n/**\n * Add some padding on text start and end so that edges can match something.\n * Intended to be called only from within patch_apply.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @return {string} The padding string added to each side.\n */\ndiff_match_patch.prototype.patch_addPadding = function(patches) {\n  var paddingLength = this.Patch_Margin;\n  var nullPadding = '';\n  for (var x = 1; x <= paddingLength; x++) {\n    nullPadding += String.fromCharCode(x);\n  }\n\n  // Bump all the patches forward.\n  for (var x = 0; x < patches.length; x++) {\n    patches[x].start1 += paddingLength;\n    patches[x].start2 += paddingLength;\n  }\n\n  // Add some padding on start of first diff.\n  var patch = patches[0];\n  var diffs = patch.diffs;\n  if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {\n    // Add nullPadding equality.\n    diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, nullPadding));\n    patch.start1 -= paddingLength;  // Should be 0.\n    patch.start2 -= paddingLength;  // Should be 0.\n    patch.length1 += paddingLength;\n    patch.length2 += paddingLength;\n  } else if (paddingLength > diffs[0][1].length) {\n    // Grow first equality.\n    var extraLength = paddingLength - diffs[0][1].length;\n    diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];\n    patch.start1 -= extraLength;\n    patch.start2 -= extraLength;\n    patch.length1 += extraLength;\n    patch.length2 += extraLength;\n  }\n\n  // Add some padding on end of last diff.\n  patch = patches[patches.length - 1];\n  diffs = patch.diffs;\n  if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {\n    // Add nullPadding equality.\n    diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, nullPadding));\n    patch.length1 += paddingLength;\n    patch.length2 += paddingLength;\n  } else if (paddingLength > diffs[diffs.length - 1][1].length) {\n    // Grow last equality.\n    var extraLength = paddingLength - diffs[diffs.length - 1][1].length;\n    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);\n    patch.length1 += extraLength;\n    patch.length2 += extraLength;\n  }\n\n  return nullPadding;\n};\n\n\n/**\n * Look through the patches and break up any which are longer than the maximum\n * limit of the match algorithm.\n * Intended to be called only from within patch_apply.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n */\ndiff_match_patch.prototype.patch_splitMax = function(patches) {\n  var patch_size = this.Match_MaxBits;\n  for (var x = 0; x < patches.length; x++) {\n    if (patches[x].length1 <= patch_size) {\n      continue;\n    }\n    var bigpatch = patches[x];\n    // Remove the big old patch.\n    patches.splice(x--, 1);\n    var start1 = bigpatch.start1;\n    var start2 = bigpatch.start2;\n    var precontext = '';\n    while (bigpatch.diffs.length !== 0) {\n      // Create one of several smaller patches.\n      var patch = new diff_match_patch.patch_obj();\n      var empty = true;\n      patch.start1 = start1 - precontext.length;\n      patch.start2 = start2 - precontext.length;\n      if (precontext !== '') {\n        patch.length1 = patch.length2 = precontext.length;\n        patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, precontext));\n      }\n      while (bigpatch.diffs.length !== 0 &&\n             patch.length1 < patch_size - this.Patch_Margin) {\n        var diff_type = bigpatch.diffs[0][0];\n        var diff_text = bigpatch.diffs[0][1];\n        if (diff_type === DIFF_INSERT) {\n          // Insertions are harmless.\n          patch.length2 += diff_text.length;\n          start2 += diff_text.length;\n          patch.diffs.push(bigpatch.diffs.shift());\n          empty = false;\n        } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 &&\n                   patch.diffs[0][0] == DIFF_EQUAL &&\n                   diff_text.length > 2 * patch_size) {\n          // This is a large deletion.  Let it pass in one chunk.\n          patch.length1 += diff_text.length;\n          start1 += diff_text.length;\n          empty = false;\n          patch.diffs.push(new diff_match_patch.Diff(diff_type, diff_text));\n          bigpatch.diffs.shift();\n        } else {\n          // Deletion or equality.  Only take as much as we can stomach.\n          diff_text = diff_text.substring(0,\n              patch_size - patch.length1 - this.Patch_Margin);\n          patch.length1 += diff_text.length;\n          start1 += diff_text.length;\n          if (diff_type === DIFF_EQUAL) {\n            patch.length2 += diff_text.length;\n            start2 += diff_text.length;\n          } else {\n            empty = false;\n          }\n          patch.diffs.push(new diff_match_patch.Diff(diff_type, diff_text));\n          if (diff_text == bigpatch.diffs[0][1]) {\n            bigpatch.diffs.shift();\n          } else {\n            bigpatch.diffs[0][1] =\n                bigpatch.diffs[0][1].substring(diff_text.length);\n          }\n        }\n      }\n      // Compute the head context for the next patch.\n      precontext = this.diff_text2(patch.diffs);\n      precontext =\n          precontext.substring(precontext.length - this.Patch_Margin);\n      // Append the end context for this patch.\n      var postcontext = this.diff_text1(bigpatch.diffs)\n                            .substring(0, this.Patch_Margin);\n      if (postcontext !== '') {\n        patch.length1 += postcontext.length;\n        patch.length2 += postcontext.length;\n        if (patch.diffs.length !== 0 &&\n            patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {\n          patch.diffs[patch.diffs.length - 1][1] += postcontext;\n        } else {\n          patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, postcontext));\n        }\n      }\n      if (!empty) {\n        patches.splice(++x, 0, patch);\n      }\n    }\n  }\n};\n\n\n/**\n * Take a list of patches and return a textual representation.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @return {string} Text representation of patches.\n */\ndiff_match_patch.prototype.patch_toText = function(patches) {\n  var text = [];\n  for (var x = 0; x < patches.length; x++) {\n    text[x] = patches[x];\n  }\n  return text.join('');\n};\n\n\n/**\n * Parse a textual representation of patches and return a list of Patch objects.\n * @param {string} textline Text representation of patches.\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\n * @throws {!Error} If invalid input.\n */\ndiff_match_patch.prototype.patch_fromText = function(textline) {\n  var patches = [];\n  if (!textline) {\n    return patches;\n  }\n  var text = textline.split('\\n');\n  var textPointer = 0;\n  var patchHeader = /^@@ -(\\d+),?(\\d*) \\+(\\d+),?(\\d*) @@$/;\n  while (textPointer < text.length) {\n    var m = text[textPointer].match(patchHeader);\n    if (!m) {\n      throw new Error('Invalid patch string: ' + text[textPointer]);\n    }\n    var patch = new diff_match_patch.patch_obj();\n    patches.push(patch);\n    patch.start1 = parseInt(m[1], 10);\n    if (m[2] === '') {\n      patch.start1--;\n      patch.length1 = 1;\n    } else if (m[2] == '0') {\n      patch.length1 = 0;\n    } else {\n      patch.start1--;\n      patch.length1 = parseInt(m[2], 10);\n    }\n\n    patch.start2 = parseInt(m[3], 10);\n    if (m[4] === '') {\n      patch.start2--;\n      patch.length2 = 1;\n    } else if (m[4] == '0') {\n      patch.length2 = 0;\n    } else {\n      patch.start2--;\n      patch.length2 = parseInt(m[4], 10);\n    }\n    textPointer++;\n\n    while (textPointer < text.length) {\n      var sign = text[textPointer].charAt(0);\n      try {\n        var line = decodeURI(text[textPointer].substring(1));\n      } catch (ex) {\n        // Malformed URI sequence.\n        throw new Error('Illegal escape in patch_fromText: ' + line);\n      }\n      if (sign == '-') {\n        // Deletion.\n        patch.diffs.push(new diff_match_patch.Diff(DIFF_DELETE, line));\n      } else if (sign == '+') {\n        // Insertion.\n        patch.diffs.push(new diff_match_patch.Diff(DIFF_INSERT, line));\n      } else if (sign == ' ') {\n        // Minor equality.\n        patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, line));\n      } else if (sign == '@') {\n        // Start of next patch.\n        break;\n      } else if (sign === '') {\n        // Blank line?  Whatever.\n      } else {\n        // WTF?\n        throw new Error('Invalid patch mode \"' + sign + '\" in: ' + line);\n      }\n      textPointer++;\n    }\n  }\n  return patches;\n};\n\n\n/**\n * Class representing one patch operation.\n * @constructor\n */\ndiff_match_patch.patch_obj = function() {\n  /** @type {!Array.<!diff_match_patch.Diff>} */\n  this.diffs = [];\n  /** @type {?number} */\n  this.start1 = null;\n  /** @type {?number} */\n  this.start2 = null;\n  /** @type {number} */\n  this.length1 = 0;\n  /** @type {number} */\n  this.length2 = 0;\n};\n\n\n/**\n * Emulate GNU diff's format.\n * Header: @@ -382,8 +481,9 @@\n * Indices are printed as 1-based, not 0-based.\n * @return {string} The GNU diff string.\n */\ndiff_match_patch.patch_obj.prototype.toString = function() {\n  var coords1, coords2;\n  if (this.length1 === 0) {\n    coords1 = this.start1 + ',0';\n  } else if (this.length1 == 1) {\n    coords1 = this.start1 + 1;\n  } else {\n    coords1 = (this.start1 + 1) + ',' + this.length1;\n  }\n  if (this.length2 === 0) {\n    coords2 = this.start2 + ',0';\n  } else if (this.length2 == 1) {\n    coords2 = this.start2 + 1;\n  } else {\n    coords2 = (this.start2 + 1) + ',' + this.length2;\n  }\n  var text = ['@@ -' + coords1 + ' +' + coords2 + ' @@\\n'];\n  var op;\n  // Escape the body of the patch with %xx notation.\n  for (var x = 0; x < this.diffs.length; x++) {\n    switch (this.diffs[x][0]) {\n      case DIFF_INSERT:\n        op = '+';\n        break;\n      case DIFF_DELETE:\n        op = '-';\n        break;\n      case DIFF_EQUAL:\n        op = ' ';\n        break;\n    }\n    text[x + 1] = op + encodeURI(this.diffs[x][1]) + '\\n';\n  }\n  return text.join('').replace(/%20/g, ' ');\n};\n\n\n// The following export code was added by @ForbesLindesay\nmodule.exports = diff_match_patch;\nmodule.exports['diff_match_patch'] = diff_match_patch;\nmodule.exports['DIFF_DELETE'] = DIFF_DELETE;\nmodule.exports['DIFF_INSERT'] = DIFF_INSERT;\nmodule.exports['DIFF_EQUAL'] = DIFF_EQUAL;", "import {findIndex, flatMap, flatten} from 'lodash';\nimport DiffMatchPatch, {Diff} from 'diff-match-patch';\nimport {ChangeData, HunkData, isDelete, isInsert, isNormal} from '../utils';\nimport pickRanges, {RangeTokenNode} from './pickRanges';\nimport {TokenizeEnhancer} from './interface';\n\nconst {DIFF_EQUAL, DIFF_DELETE, DIFF_INSERT} = DiffMatchPatch;\n\nfunction findChangeBlocks(changes: ChangeData[]): ChangeData[][] {\n    const start = findIndex(changes, change => !isNormal(change));\n\n    if (start === -1) {\n        return [];\n    }\n\n    const end = findIndex(changes, change => !!isNormal(change), start);\n\n    if (end === -1) {\n        return [changes.slice(start)];\n    }\n\n    return [\n        changes.slice(start, end),\n        ...findChangeBlocks(changes.slice(end)),\n    ];\n}\n\nfunction groupDiffs(diffs: Diff[]): [Diff[], Diff[]] {\n    return diffs.reduce<[Diff[], Diff[]]>(\n        ([oldDiffs, newDiffs], diff) => {\n            const [type] = diff;\n\n            switch (type) {\n                case DIFF_INSERT:\n                    newDiffs.push(diff);\n                    break;\n                case DIFF_DELETE:\n                    oldDiffs.push(diff);\n                    break;\n                default:\n                    oldDiffs.push(diff);\n                    newDiffs.push(diff);\n                    break;\n            }\n\n            return [oldDiffs, newDiffs];\n        },\n        [[], []]\n    );\n}\n\nfunction splitDiffToLines(diffs: Diff[]): Diff[][] {\n    return diffs.reduce<Diff[][]>(\n        (lines, [type, value]) => {\n            const currentLines = value.split('\\n');\n\n            const [currentLineRemaining, ...nextLines] = currentLines.map((line: string): Diff => [type, line]);\n            const next = [\n                ...lines.slice(0, -1),\n                [...lines[lines.length - 1], currentLineRemaining],\n                ...nextLines.map(line => [line]),\n            ];\n            return next;\n        },\n        [[]]\n    );\n}\n\nfunction diffsToEdits(diffs: Diff[], lineNumber: number): RangeTokenNode[] {\n    const output = diffs.reduce<[RangeTokenNode[], number]>(\n        (output, diff) => {\n            const [edits, start] = output;\n            const [type, value] = diff;\n            if (type !== DIFF_EQUAL) {\n                const edit: RangeTokenNode = {\n                    type: 'edit',\n                    lineNumber: lineNumber,\n                    start: start,\n                    length: value.length,\n                };\n                edits.push(edit);\n            }\n\n            return [edits, start + value.length];\n        },\n        [[], 0]\n    );\n\n    return output[0];\n}\n\nfunction convertToLinesOfEdits(linesOfDiffs: Diff[][], startLineNumber: number) {\n    return flatMap(linesOfDiffs, (diffs, i) => diffsToEdits(diffs, startLineNumber + i));\n}\n\nfunction diffText(x: string, y: string): [Diff[], Diff[]] {\n    const dmp = new DiffMatchPatch();\n    const diffs = dmp.diff_main(x, y);\n    dmp.diff_cleanupSemantic(diffs);\n\n    // for only one diff, it's a insertion or deletion, we won't mark it in UI\n    if (diffs.length <= 1) {\n        return [[], []];\n    }\n\n    return groupDiffs(diffs);\n}\n\nfunction diffChangeBlock(changes: ChangeData[]): [RangeTokenNode[], RangeTokenNode[]] {\n    const [oldSource, newSource] = changes.reduce(\n        ([oldSource, newSource], change) => (\n            isDelete(change)\n                ? [oldSource + (oldSource ? '\\n' : '') + change.content, newSource]\n                : [oldSource, newSource + (newSource ? '\\n' : '') + change.content]\n        ),\n        ['', '']\n    );\n\n    const [oldDiffs, newDiffs] = diffText(oldSource, newSource);\n\n    if (oldDiffs.length === 0 && newDiffs.length === 0) {\n        return [[], []];\n    }\n\n    const getLineNumber = (change: ChangeData | undefined) => {\n        if (!change || isNormal(change)) {\n            return undefined;\n        }\n\n        return change.lineNumber;\n    };\n    const oldStartLineNumber = getLineNumber(changes.find(isDelete));\n    const newStartLineNumber = getLineNumber(changes.find(isInsert));\n\n    if (oldStartLineNumber === undefined || newStartLineNumber === undefined) {\n        throw new Error('Could not find start line number for edit');\n    }\n\n    const oldEdits = convertToLinesOfEdits(splitDiffToLines(oldDiffs), oldStartLineNumber);\n    const newEdits = convertToLinesOfEdits(splitDiffToLines(newDiffs), newStartLineNumber);\n\n    return [oldEdits, newEdits];\n}\n\nfunction diffByLine(changes: ChangeData[]): [RangeTokenNode[], RangeTokenNode[]] {\n    const [oldEdits, newEdits] = changes.reduce<[RangeTokenNode[], RangeTokenNode[], ChangeData | null]>(\n        ([oldEdits, newEdits, previousChange], currentChange) => {\n            if (!previousChange || !isDelete(previousChange) || !isInsert(currentChange)) {\n                return [oldEdits, newEdits, currentChange];\n            }\n\n            const [oldDiffs, newDiffs] = diffText(previousChange.content, currentChange.content);\n            return [\n                oldEdits.concat(diffsToEdits(oldDiffs, previousChange.lineNumber)),\n                newEdits.concat(diffsToEdits(newDiffs, currentChange.lineNumber)),\n                currentChange,\n            ];\n        },\n        [[], [], null]\n    );\n    return [oldEdits, newEdits];\n}\n\nexport type MarkEditsType = 'block' | 'line';\n\nexport interface MarkEditsOptions {\n    type?: MarkEditsType;\n}\n\nexport default function markEdits(hunks: HunkData[], {type = 'block'}: MarkEditsOptions = {}): TokenizeEnhancer {\n    const changeBlocks = flatMap(hunks.map(hunk => hunk.changes), findChangeBlocks);\n    const findEdits = type === 'block' ? diffChangeBlock : diffByLine;\n\n    const [oldEdits, newEdits] = changeBlocks.map(findEdits).reduce(\n        ([oldEdits, newEdits], [currentOld, currentNew]) => [\n            oldEdits.concat(currentOld),\n            newEdits.concat(currentNew),\n        ],\n        [[], []]\n    );\n\n    return pickRanges(flatten(oldEdits), flatten(newEdits));\n}\n", "import {flatMap} from 'lodash';\nimport {TokenizeEnhancer, TokenPath} from './interface';\nimport {leafOf, replace} from './utils';\n\nfunction markInPaths(word: string, name: string, replacement: string) {\n    return (paths: TokenPath[]) => flatMap(\n        paths,\n        path => {\n            const leaf = leafOf(path);\n\n            if (!leaf.value.includes(word)) {\n                return [path];\n            }\n\n            const segments = leaf.value.split(word);\n\n            return segments.reduce<TokenPath[]>(\n                (output, text, i) => {\n                    if (i !== 0) {\n                        output.push(replace(path, {type: 'mark', markType: name, value: replacement}));\n                    }\n\n                    if (text) {\n                        output.push(replace(path, {...leaf, value: text}));\n                    }\n\n                    return output;\n                },\n                []\n            );\n        }\n    );\n}\n\nexport default function markWord(word: string, name: string, replacement = word): TokenizeEnhancer {\n    const mark = markInPaths(word, name, replacement);\n\n    return ([oldLinesOfPaths, newLinesOfPaths]) => [\n        oldLinesOfPaths.map(mark),\n        newLinesOfPaths.map(mark),\n    ];\n}\n", "import toTokenTrees, {ToTokenTreeOptions} from './toTokenTrees';\nimport normalizeToLines from './normalizeToLines';\nimport backToTree from './backToTree';\nimport {HunkData} from '../utils';\nimport {TokenizeEnhancer, TokenNode, TokenPath} from './interface';\n\nexport {default as pickRanges} from './pickRanges';\nexport {default as markEdits} from './markEdits';\nexport {default as markWord} from './markWord';\nexport type {Pair, TextNode, TokenNode, TokenPath, TokenizeEnhancer} from './interface';\nexport type {MarkEditsOptions, MarkEditsType} from './markEdits';\nexport type {RangeTokenNode} from './pickRanges';\n\nexport type TokenizeOptions = ToTokenTreeOptions & {enhancers?: TokenizeEnhancer[]};\n\nexport interface HunkTokens {\n    old: TokenNode[][];\n    new: TokenNode[][];\n}\n\nexport const tokenize = (hunks: HunkData[], {enhancers = [], ...options}: TokenizeOptions = {}): HunkTokens => {\n    const [oldTokenTree, newTokenTree] = toTokenTrees(hunks, options);\n    const [oldLinesOfPaths, newLinesOfPaths] = [normalizeToLines(oldTokenTree), normalizeToLines(newTokenTree)];\n\n    const enhance = (pair: [TokenPath[][], TokenPath[][]]) => enhancers.reduce(\n        (input, enhance) => enhance(input),\n        pair\n    );\n    const [oldEnhanced, newEnhanced] = enhance([oldLinesOfPaths, newLinesOfPaths]);\n    const [oldTrees, newTrees] = [oldEnhanced.map(backToTree), newEnhanced.map(backToTree)];\n    return {\n        old: oldTrees.map(root => root.children ?? []),\n        new: newTrees.map(root => root.children ?? []),\n    };\n};\n", "import {useMemo} from 'react';\nimport {expandCollapsedBlockBy, HunkData, Source} from '../utils';\n\nexport default function useMinCollapsedLines(minLinesExclusive: number, hunks: HunkData[], oldSource: Source | null) {\n    const renderingHunks = useMemo(\n        () => {\n            if (!oldSource) {\n                return hunks;\n            }\n\n            const predicate = (lines: number) => lines < minLinesExclusive;\n            return expandCollapsedBlockBy(hunks, oldSource, predicate);\n        },\n        [minLinesExclusive, hunks, oldSource]\n    );\n    return renderingHunks;\n}\n", "import {Reducer, useReducer, useRef} from 'react';\n\ninterface ClearCommand {\n    type: 'clear';\n}\n\ninterface ModifyCommand<T> {\n    type: 'push' | 'toggle' | 'only';\n    value: T;\n}\n\ntype UpdateCommand<T> = ClearCommand | ModifyCommand<T>;\n\nfunction updateCollection<T>(collection: T[], command: UpdateCommand<T>) {\n    switch (command.type) {\n        case 'push':\n            return [...collection, command.value];\n        case 'clear':\n            return collection.length ? [] : collection;\n        case 'toggle':\n            return collection.includes(command.value)\n                ? collection.filter(item => item !== command.value)\n                : collection.concat(command.value);\n        case 'only':\n            return [command.value];\n        default:\n            return collection;\n    }\n}\n\nexport function useCollection<T>() {\n    const [collection, dispatch] = useReducer<Reducer<T[], UpdateCommand<T>>>(updateCollection, []);\n\n    return {\n        collection,\n        clear() {\n            dispatch({type: 'clear'});\n        },\n        push(value: T) {\n            dispatch({value, type: 'push'});\n        },\n        toggle(value: T) {\n            dispatch({value, type: 'toggle'});\n        },\n        only(value: T) {\n            dispatch({value, type: 'only'});\n        },\n    };\n}\n\n// This is actually a hack around the lack of custom comparator support in `useEffect` hook.\nexport function useCustomEqualIdentifier<T>(value: T, equals: (x: T, y: T | undefined) => boolean) {\n    const cache = useRef<T | undefined>(undefined);\n    const identifier = useRef(0);\n    const isEqual = equals(value, cache.current);\n\n    // TODO: this is not cocurrency safe\n    if (!isEqual) {\n        cache.current = value;\n        identifier.current = identifier.current + 1;\n    }\n\n    return identifier.current;\n}\n", "import {Hunk} from 'gitdiff-parser';\nimport {useEffect} from 'react';\nimport {ChangeEventArgs} from '../context';\nimport {getChangeKey} from '../utils';\nimport {useCollection} from './helpers';\n\nexport interface UseChangeSelectOptions {\n    multiple?: boolean;\n}\n\nexport default function useChangeSelect(hunks: Hunk[], {multiple = false}: UseChangeSelectOptions = {}) {\n    const {collection, clear, toggle, only} = useCollection<string>();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    useEffect(clear, [hunks]);\n\n    return [\n        collection,\n        ({change}: ChangeEventArgs) => {\n            if (!change) {\n                return;\n            }\n\n            const changeKey = getChangeKey(change);\n            if (multiple) {\n                toggle(changeKey);\n            }\n            else {\n                only(changeKey);\n            }\n        },\n    ] as const;\n}\n", "import {useEffect, useMemo} from 'react';\nimport {expandFromRawCode, HunkData, Source} from '../utils';\nimport {useCollection} from './helpers';\n\nexport default function useSourceExpansion(hunks: HunkData[], oldSource: Source | null) {\n    const {collection: expandedRanges, clear, push} = useCollection<[number, number]>();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    useEffect(clear, [hunks, oldSource]);\n    const linesOfOldSource = useMemo(\n        () => (Array.isArray(oldSource) ? oldSource : (oldSource || '').split('\\n')),\n        [oldSource]\n    );\n    const renderingHunks = useMemo(\n        () => {\n            if (!linesOfOldSource.length) {\n                return hunks;\n            }\n\n            return expandedRanges.reduce(\n                (hunks, [start, end]) => expandFromRawCode(hunks, linesOfOldSource, start, end),\n                hunks\n            );\n        },\n        [linesOfOldSource, hunks, expandedRanges]\n    );\n\n    return [\n        renderingHunks,\n        (start: number, end: number) => push([start, end]),\n    ] as const;\n}\n", "export type validObjectValue = Record<string, any> | null | undefined;\n\nexport default function shallowEqualObjects<T>(\n  objA: validObjectValue,\n  objB: validObjectValue\n): boolean {\n  if (objA === objB) {\n    return true;\n  }\n\n  if (!objA || !objB) {\n    return false;\n  }\n\n  const aKeys = Object.keys(objA);\n  const bKeys = Object.keys(objB);\n  const len = aKeys.length;\n\n  if (bKeys.length !== len) {\n    return false;\n  }\n\n  for (let i = 0; i < len; i++) {\n    const key = aKeys[i];\n\n    if (\n      objA[key] !== objB[key] ||\n      !Object.prototype.hasOwnProperty.call(objB, key)\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n", "import {useState, useRef, useEffect} from 'react';\nimport {shallowEqualArrays, shallowEqualObjects} from 'shallow-equal';\nimport {flatMap} from 'lodash';\nimport {useCustomEqualIdentifier} from './helpers';\nimport {HunkData, isNormal} from '../utils';\nimport {HunkTokens} from '../tokenize';\n\nconst uid = (() => {\n    let current = 0;\n\n    return () => {\n        current = current + 1;\n        return current;\n    };\n})();\n\nfunction findAbnormalChanges(hunks: HunkData[]) {\n    return flatMap(hunks, hunk => hunk.changes.filter(change => !isNormal(change)));\n}\n\nfunction areHunksEqual(xHunks: HunkData[], yHunks: HunkData[]) {\n    const xChanges = findAbnormalChanges(xHunks);\n    const yChanges = findAbnormalChanges(yHunks);\n\n    return shallowEqualArrays(xChanges, yChanges);\n}\n\nexport interface TokenizePayload {\n    hunks: HunkData[];\n    oldSource: string | null;\n}\n\nexport type ShouldTokenize<P extends TokenizePayload> = (current: P, prev: P | undefined) => boolean;\n\nfunction defaultShouldTokenize<P extends TokenizePayload>(current: P, prev: P | undefined) {\n    if (!prev) {\n        return true;\n    }\n\n    const {hunks: currentHunks, ...currentPayload} = current;\n    const {hunks: prevHunks, ...prevPayload} = prev;\n    if (currentPayload.oldSource !== prevPayload.oldSource) {\n        return true;\n    }\n\n    // When `oldSource` is provided, we can get the new source by applying diff,\n    // so when hunks keep identical, the tokenize result will always remain the same.\n    if (currentPayload.oldSource) {\n        return !shallowEqualObjects(currentPayload, prevPayload) || !areHunksEqual(currentHunks, prevHunks);\n    }\n\n    return currentHunks !== prevHunks || !shallowEqualObjects(currentPayload, prevPayload);\n}\n\nexport interface TokenizeWorkerOptions<P extends TokenizePayload> {\n    shouldTokenize?: ShouldTokenize<P>;\n}\n\ninterface WorkerResultSuccess {\n    success: true;\n    id: string;\n    tokens: HunkTokens;\n}\n\ninterface WorkerResultFail {\n    success: false;\n    reason: string;\n}\n\ninterface WorkerMessageData {\n    id: number;\n    payload: WorkerResultSuccess | WorkerResultFail;\n}\n\nexport interface TokenizeResult {\n    tokens: HunkTokens | null;\n    tokenizationFailReason: string | null;\n}\n\nexport default function useTokenizeWorker<P extends TokenizePayload>(\n    worker: Worker,\n    payload: P,\n    options: TokenizeWorkerOptions<P> = {}\n) {\n    const {shouldTokenize = defaultShouldTokenize} = options;\n    const payloadIdentifier = useCustomEqualIdentifier(\n        payload,\n        (current, previous) => !shouldTokenize(current, previous)\n    );\n    const [tokenizeResult, setTokenizeResult] = useState<TokenizeResult>({tokens: null, tokenizationFailReason: null});\n    const job = useRef<number | null>(null);\n    useEffect(\n        () => {\n            const receiveTokens = ({data: {payload, id}}: MessageEvent<WorkerMessageData>) => {\n                if (id !== job.current) {\n                    return;\n                }\n\n                if (payload.success) {\n                    setTokenizeResult({tokens: payload.tokens, tokenizationFailReason: null});\n                }\n                else {\n                    setTokenizeResult({tokens: null, tokenizationFailReason: payload.reason});\n                }\n            };\n            worker.addEventListener('message', receiveTokens);\n            return () => worker.removeEventListener('message', receiveTokens);\n        },\n        [worker] // We don't really expect the worker to be changed in an application's lifecycle\n    );\n    useEffect(\n        () => {\n            job.current = uid();\n            const data = {\n                payload,\n                id: job.current,\n                type: 'tokenize',\n            };\n            worker.postMessage(data);\n        },\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [payloadIdentifier, worker, shouldTokenize] // TODO: How about worker changes when payload keeps identical?\n    );\n\n    return tokenizeResult;\n}\n", "export type validArrayValue = any[] | null | undefined;\n\nexport default function shallowEqualArrays(\n  arrA: validArrayValue,\n  arrB: validArrayValue\n): boolean {\n  if (arrA === arrB) {\n    return true;\n  }\n\n  if (!arrA || !arrB) {\n    return false;\n  }\n\n  const len = arrA.length;\n\n  if (arrB.length !== len) {\n    return false;\n  }\n\n  for (let i = 0; i < len; i++) {\n    if (arrA[i] !== arrB[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n", "import {ComponentType} from 'react';\n\n// Based on https://github.com/acdlite/recompose/blob/a255b23/src/packages/recompose/getDisplayName.js\nfunction getDisplayName(Component: ComponentType<any>) {\n    return (typeof Component === 'string' || Component == null)\n        ? Component\n        : Component.displayName || Component.name || 'Component';\n}\n\n// based on https://github.com/acdlite/recompose/blob/d55575f/src/packages/recompose/wrapDisplayName.js\nexport function wrapDisplayName(BaseComponent: ComponentType<any>, hocName: string) {\n    return `${hocName}(${getDisplayName(BaseComponent)})`;\n}\n", "import {ComponentType} from 'react';\nimport {useSourceExpansion} from '../hooks';\nimport {HunkData, Source} from '../utils';\nimport {wrapDisplayName} from './wrapDisplayName';\n\nexport default function withSourceExpansion() {\n    return function wrap<P extends {hunks: HunkData[], oldSource: Source}>(ComponentIn: ComponentType<P>) {\n        function ComponentOut(props: P & {onExpandRange: (start: number, end: number) => void}) {\n            const [renderingHunks, expandRange] = useSourceExpansion(props.hunks, props.oldSource);\n\n            return (\n                <ComponentIn\n                    {...props}\n                    hunks={renderingHunks}\n                    onExpandRange={expandRange}\n                />\n            );\n        }\n\n        ComponentOut.displayName = wrapDisplayName(ComponentIn, 'withSourceExpansion');\n\n        return ComponentOut;\n    };\n}\n", "import {ComponentType} from 'react';\nimport {useMinCollapsedLines} from '../hooks';\nimport {DiffProps} from '../Diff';\nimport {Source} from '../utils';\nimport {wrapDisplayName} from './wrapDisplayName';\n\nexport default function minCollapsedLines(minLinesExclusive: number) {\n    return function wrap(ComponentIn: ComponentType<DiffProps>) {\n        function ComponentOut(props: DiffProps & {oldSource: Source}) {\n            const renderingHunks = useMinCollapsedLines(minLinesExclusive, props.hunks, props.oldSource);\n            return <ComponentIn {...props} hunks={renderingHunks} />;\n        }\n\n        ComponentOut.displayName = wrapDisplayName(ComponentIn, 'minCollapsedLines');\n\n        return ComponentOut;\n    };\n}\n", "import {ComponentType} from 'react';\nimport {useChangeSelect, UseChangeSelectOptions} from '../hooks';\nimport {ChangeEventArgs} from '../context';\nimport {HunkData} from '../utils';\nimport {wrapDisplayName} from './wrapDisplayName';\n\nexport default function withChangeSelect(options: UseChangeSelectOptions) {\n    return function wrap<P extends {hunks: HunkData[]}>(ComponentIn: ComponentType<P>) {\n        function ComponentOut(props: P & {onToggleChangeSelection: (args: ChangeEventArgs) => void}) {\n            const [selectedChanges, toggleChangeSelection] = useChangeSelect(props.hunks, options);\n            return (\n                <ComponentIn\n                    {...props}\n                    selectedChanges={selectedChanges}\n                    onToggleChangeSelection={toggleChangeSelection}\n                />\n            );\n        }\n\n        ComponentOut.displayName = wrapDisplayName(ComponentIn, 'withChangeSelect');\n\n        return ComponentOut;\n    };\n}\n", "import {ComponentType} from 'react';\nimport {TokenizePayload, TokenizeResult, TokenizeWorkerOptions, useTokenizeWorker} from '../hooks';\nimport {HunkData, Source} from '../utils';\nimport {wrapDisplayName} from './wrapDisplayName';\n\nexport interface RequiredProps {\n    hunks: HunkData[];\n    oldSource: Source;\n    language: string;\n}\n\nfunction defaultMapPayload(data: RequiredProps) {\n    return data;\n}\n\ninterface ToeknizeWorkerHocOptions<T extends TokenizePayload> extends TokenizeWorkerOptions<T> {\n    mapPayload?: <P extends RequiredProps>(payload: RequiredProps, props: P) => any;\n}\n\nexport default function withTokenizeWorkerwithTokenizeWorker<T extends TokenizePayload>(\n    worker: Worker,\n    options: ToeknizeWorkerHocOptions<T> = {}\n) {\n    const {mapPayload = defaultMapPayload, ...hookOptions} = options;\n\n    function resolveMessagePayload<P extends RequiredProps>(props: P): T {\n        const {hunks, oldSource, language} = props;\n        const input = {language, oldSource, hunks};\n        return mapPayload(input, props);\n    }\n\n    return function wrap<P>(ComponentIn: ComponentType<P & TokenizeResult>) {\n        function ComponentOut(props: P & RequiredProps) {\n            const payload = resolveMessagePayload(props);\n            const tokenizationResult = useTokenizeWorker(worker, payload, hookOptions);\n\n            return <ComponentIn {...props} {...tokenizationResult} />;\n        }\n\n        ComponentOut.displayName = wrapDisplayName(ComponentIn, 'withTokenizeWorker');\n\n        return ComponentOut;\n    };\n}\n"],
  "mappings": "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",
  "names": ["hasOwn", "hasOwnProperty", "classNames", "classes", "i", "arguments", "length", "arg", "argType", "push", "Array", "isArray", "inner", "apply", "toString", "Object", "prototype", "includes", "key", "call", "join", "module", "exports", "default", "window", "DEFAULT_CONTEXT_VALUE", "hunkClassName", "lineClassName", "gutterClassName", "codeClassName", "monotonous", "gutterType", "viewType", "widgets", "hideGutter", "selectedChanges", "generateAnchorID", "generateLineClassName", "renderGutter", "_ref", "renderDefault", "wrapInAnchor", "codeEvents", "gutterEvents", "ContextType", "createContext", "Provider", "useDiffSettings", "useContext", "root", "parsePathFromFirstLine", "line", "filesStr", "slice", "oldPath", "newPath", "indexOf", "segs", "split", "nextQuoteIndex", "newQuoteIndex", "parser", "parse", "source", "currentInfo", "currentHunk", "changeOldLine", "changeNewLine", "paths", "infos", "stat", "lines", "linesLen", "hunks", "oldEndingNewLine", "newEndingNewLine", "simiLine", "currentInfoType", "simiLoop", "spaceIndex", "infoType", "leftStr", "similarity", "parseInt", "revs", "oldRevision", "newRevision", "oldMode", "newMode", "infoStr", "type", "isBinary", "match", "exec", "content", "oldStart", "newStart", "oldLines", "newLines", "changes", "typeChar", "change", "isInsert", "lineNumber", "isDelete", "isNormal", "oldLineNumber", "newLineNumber", "lastChange", "mapHunk", "hunk", "options", "nearbySequences", "_changes$reduce", "reduce", "current", "_ref2", "_slicedToArray", "result", "last", "lastDeletionIndex", "splice", "_objectSpread", "isPlain", "parseDiff", "text", "diffText", "startsWith", "indexOfFirstLineBreak", "indexOfSecondLineBreak", "firstLine", "secondLine", "concat", "trimStart", "map", "file", "first", "array", "sideToProperty", "side", "computeLineNumberFactory", "isInHunkFactory", "startProperty", "linesProperty", "start", "end", "isBetweenHunksFactory", "previousHunk", "nextHunk", "findChangeByLineNumberFactory", "computeLineNumber", "findContainerHunk", "_sideToProperty2", "isInHunk", "find", "containerHunk", "getCorrespondingLineNumberFactory", "baseSide", "anotherSide", "_sideToProperty4", "baseStart", "baseLines", "_sideToProperty6", "correspondingStart", "correspondingLines", "baseLineNumber", "correspondingLineNumber", "isBetweenHunks", "firstHunk", "spanFromStart", "lastHunk", "spanFromEnd", "changeIndex", "findIndex", "possibleCorrespondingChangeIndex", "possibleCorrespondingChange", "negativeChangeType", "Error", "_baseFindIndex", "predicate", "fromIndex", "fromRight", "index", "_listCacheClear", "this", "__data__", "size", "eq_1", "value", "other", "_assocIndexOf", "eq", "_listCacheDelete", "data", "assocIndexOf", "pop", "_listCacheGet", "_listCacheHas", "_listCacheSet", "ListCache", "entries", "clear", "entry", "set", "listCacheClear", "listCacheDelete", "get", "listCacheGet", "has", "listCacheHas", "listCacheSet", "_ListCache", "_stackClear", "_stackDelete", "_stackGet", "_stackHas", "_freeGlobal", "global", "freeSelf", "self", "_root", "freeGlobal", "Function", "_Symbol", "Symbol", "objectProto", "nativeObjectToString", "symToStringTag", "toStringTag", "_getRawTag", "isOwn", "tag", "unmasked", "e", "_objectToString", "_baseGetTag", "getRawTag", "objectToString", "isObject_1", "isFunction_1", "isObject", "baseGetTag", "_coreJsData", "maskSrcKey", "uid", "coreJsData", "keys", "IE_PROTO", "_isMasked", "func", "funcToString", "_toSource", "reIsHostCtor", "funcProto", "reIsNative", "RegExp", "replace", "_baseIsNative", "isMasked", "isFunction", "test", "toSource", "_getValue", "object", "_getNative", "getValue", "baseIsNative", "_Map", "getNative", "_nativeCreate", "_hashClear", "nativeCreate", "_hashDelete", "_hashGet", "_hashHas", "_hashSet", "Hash", "hashClear", "hashDelete", "hashGet", "hashHas", "hashSet", "_Hash", "_mapCacheClear", "hash", "Map", "string", "_isKeyable", "_getMapData", "isKeyable", "_mapCacheDelete", "getMapData", "_mapCacheGet", "_mapCacheHas", "_mapCacheSet", "MapCache", "mapCacheClear", "mapCacheDelete", "mapCacheGet", "mapCacheHas", "mapCacheSet", "_MapCache", "_stackSet", "pairs", "LARGE_ARRAY_SIZE", "Stack", "stackClear", "stackDelete", "stackGet", "stackHas", "stackSet", "_Stack", "_setCacheAdd", "_setCacheHas", "SetCache", "values", "add", "setCacheAdd", "setCacheHas", "_SetCache", "_arraySome", "_cacheHas", "cache", "_equalArrays", "bitmask", "customizer", "equalFunc", "stack", "isPartial", "arrLength", "othLength", "arrStacked", "othStacked", "seen", "arrValue", "othValue", "compared", "arraySome", "othIndex", "cacheHas", "_Uint8Array", "Uint8Array", "_mapToArray", "forEach", "_setToArray", "symbolProto", "symbolValueOf", "valueOf", "_equalByTag", "byteLength", "byteOffset", "buffer", "name", "message", "convert", "mapToArray", "setToArray", "stacked", "equalArrays", "_arrayPush", "offset", "isArray_1", "_baseGetAllKeys", "keysFunc", "symbolsFunc", "arrayPush", "_arrayFilter", "resIndex", "stubArray_1", "propertyIsEnumerable", "nativeGetSymbols", "getOwnPropertySymbols", "_getSymbols", "arrayFilter", "symbol", "stubArray", "_baseTimes", "n", "iteratee", "isObjectLike_1", "_baseIsArguments", "isObjectLike", "isArguments_1", "baseIsArguments", "stubFalse_1", "freeExports", "nodeType", "freeModule", "Buffer", "isBuffer", "stubFalse", "reIsUint", "_isIndex", "isLength_1", "typedArrayTags", "_baseIsTypedArray", "isLength", "_baseUnary", "freeProcess", "process", "nodeUtil", "types", "require", "binding", "nodeIsTypedArray", "isTypedArray", "isTypedArray_1", "baseUnary", "baseIsTypedArray", "_arrayLikeKeys", "inherited", "isArr", "isArg", "isArguments", "isBuff", "isType", "skipIndexes", "baseTimes", "String", "isIndex", "_isPrototype", "Ctor", "constructor", "_nativeKeys", "transform", "_baseKeys", "isPrototype", "nativeKeys", "isArrayLike_1", "keys_1", "isArrayLike", "arrayLikeKeys", "baseKeys", "_getAllKeys", "baseGetAllKeys", "getSymbols", "_equalObjects", "objProps", "getAllKeys", "objLength", "objStacked", "skipCtor", "objValue", "objCtor", "othCtor", "_DataView", "_Promise", "_Set", "_WeakMap", "dataViewCtorString", "DataView", "mapCtorString", "promiseCtorString", "Promise", "setCtorString", "Set", "weakMapCtorString", "WeakMap", "getTag", "ArrayBuffer", "resolve", "ctorString", "_getTag", "objectTag", "_baseIsEqualDeep", "objIsArr", "othIsArr", "objTag", "othTag", "objIsObj", "othIsObj", "isSameTag", "equalByTag", "objIsWrapped", "othIsWrapped", "objUnwrapped", "othUnwrapped", "equalObjects", "_baseIsEqual", "baseIsEqual", "baseIsEqualDeep", "_baseIsMatch", "matchData", "noCustomizer", "srcValue", "COMPARE_PARTIAL_FLAG", "_isStrictComparable", "_getMatchData", "isStrictComparable", "_matchesStrictComparable", "_baseMatches", "getMatchData", "matchesStrictComparable", "baseIsMatch", "isSymbol_1", "reIsDeepProp", "reIsPlainProp", "_isKey", "isSymbol", "memoize", "resolver", "TypeError", "memoized", "args", "Cache", "memoize_1", "rePropName", "reEscapeChar", "_stringToPath", "charCodeAt", "number", "quote", "subString", "_arrayMap", "symbolToString", "_baseToString", "baseToString", "arrayMap", "toString_1", "_castPath", "isKey", "stringToPath", "_toKey", "_baseGet", "path", "castPath", "toKey", "get_1", "defaultValue", "baseGet", "_baseHasIn", "_hasPath", "hasFunc", "hasIn_1", "hasPath", "baseHasIn", "_baseMatchesProperty", "hasIn", "identity_1", "_baseProperty", "_basePropertyDeep", "property_1", "baseProperty", "basePropertyDeep", "_baseIteratee", "identity", "baseMatchesProperty", "baseMatches", "property", "reWhitespace", "_trimmedEndIndex", "charAt", "reTrimStart", "_baseTrim", "trimmedEndIndex", "reIsBadHex", "reIsBinary", "reIsOctal", "freeParseInt", "toNumber_1", "baseTrim", "toFinite_1", "toNumber", "toInteger_1", "toFinite", "remainder", "nativeMax", "Math", "max", "nativeMin", "min", "findLastIndex_1", "toInteger", "baseFindIndex", "baseIteratee", "computeOldLineNumber", "computeNewLineNumber", "getOldRangeFromHunk", "createHunkFromChanges", "textLinesToHunk", "oldStartLine", "newStartLine", "sliceHunk", "oldEndLine", "startIndex", "nearestHeadingNocmalChangeIndex", "_findLastIndex", "endIndex", "mergeHunk", "_getOldRangeFromHunk2", "previousStart", "previousEnd", "_getOldRangeFromHunk4", "nextStart", "nextEnd", "_toConsumableArray", "head", "tail", "appendOrMergeHunk", "mergedHunk", "insertHunk", "insertion", "insertionOldLineNumber", "insertPosition", "_ref3", "getChangeKey", "prefix", "getCorrespondingNewLineNumber", "isOldLineNumberInHunk", "isOldLineNumberBetweenHunks", "splitRangeToValidOnes", "correspondingHunkIndex", "correspondingHunk", "headingChangesCount", "validEnd", "nearestNormalChangeIndex", "validStartChange", "validStart", "adjacentChangesCount", "expandFromRawCode", "range", "slicedLines", "slicedHunk", "getCollapsedLinesCountBetween", "expandCollapsedBlockBy", "linesOfCode", "initialExpandingBlocks", "expandingBlocks", "_ref4", "_ref5", "findChangeByOldLineNumber", "findChangeByNewLineNumber", "getCorrespondingOldLineNumber", "_defineProperty", "_baseAssignValue", "defineProperty", "configurable", "enumerable", "writable", "_createBaseFor", "iterable", "props", "_baseFor", "createBaseFor", "_baseForOwn", "baseFor", "mapValues_1", "baseForOwn", "baseAssignValue", "defaultRenderToken", "markType", "properties", "className", "children", "renderWithClassName", "_jsx", "legacyClassName", "isEmptyToken", "tokens", "token", "CodeCell", "changeKey", "renderToken", "attributes", "_objectWithoutProperties", "_excluded", "actualRenderToken", "CodeCell$1", "memo", "renderDefaultBy", "wrapInAnchorBy", "gutterAnchor", "anchorTarget", "element", "href", "composeCallback", "own", "custom", "useBoundCallbacks", "callbacks", "hoverOn", "hoverOff", "useMemo", "output", "_mapValues", "fn", "onMouseEnter", "onMouseLeave", "renderGutterCell", "events", "inHoverState", "gutterOptions", "UnifiedChange", "_useState2", "setValue", "selected", "_useBoolean", "useState", "useCallback", "_useBoolean2", "hover", "eventArg", "boundGutterEvents", "boundCodeEvents", "anchorID", "defaultGenerate", "gutterClassNameValue", "codeClassNameValue", "_jsxs", "id", "UnifiedChange$1", "UnifiedWidget", "colSpan", "UnifiedHunk", "childrenProps", "_excluded2", "elements", "widget", "changeProps", "tokensOfLine", "SIDE_OLD", "useCallbackOnSide", "setHover", "customCallbacks", "markHover", "unmarkHover", "renderCells", "gutterAnchorTarget", "sideName", "gutterProps", "SplitChange", "oldChange", "newChange", "oldSelected", "newSelected", "oldTokens", "newTokens", "oldGutterEvents", "newGutterEvents", "oldCodeEvents", "newCodeEvents", "oldAnchorID", "newAnchorID", "commons", "oldArgs", "newArgs", "lineTypeClassName", "SplitChange$1", "SplitWidget", "oldElement", "newElement", "keyForPair", "x", "y", "SplitHunk", "findWidget", "next", "rowChanges", "oldWidget", "newWidget", "item", "oldValue", "newValue", "old", "Hunk", "_useDiffSettings", "context", "RenderingHunk", "noop", "setUserSelectStyle", "selectable", "HTMLElement", "style", "userSelect", "defaultRenderChildren", "Diff", "diffType", "optimizeSelection", "_props$hunkClassName", "_props$lineClassName", "_props$generateLineCl", "_props$gutterClassNam", "_props$codeClassName", "_props$gutterType", "_props$viewType", "_props$gutterEvents", "_props$codeEvents", "_props$generateAnchor", "_props$selectedChange", "_props$widgets", "_props$renderGutter", "_props$children", "useRef", "enableColumnSelection", "target", "button", "closestCell", "document", "documentElement", "classList", "contains", "parentElement", "selection", "getSelection", "removeAllRanges", "_step", "_iterator", "_createForOfIteratorHelper", "querySelectorAll", "s", "done", "cells", "err", "f", "onTableMouseDown", "cols", "settingsContextValue", "ref", "onMouseDown", "warning", "printWarning", "format", "len", "argIndex", "console", "error", "condition", "warning_1", "SplitDecoration", "contentClassName", "computedClassName", "computedGutterClassName", "computedContentClassName", "columnCount", "headerContentColSpan", "Children", "count", "_children", "gutter", "UnifiedDecoration", "Decoration", "_props$className", "_props$contentClassNa", "RenderingDecoration", "childrenCount", "_arrayAggregator", "setter", "accumulator", "_createBaseEach", "eachFunc", "collection", "_baseEach", "createBaseEach", "_baseAggregator", "baseEach", "_createAggregator", "initializer", "arrayAggregator", "baseAggregator", "keyBy_1", "createAggregator", "spreadableSymbol", "isConcatSpreadable", "_isFlattenable", "_baseFlatten", "baseFlatten", "depth", "isStrict", "isFlattenable", "_baseMap", "map_1", "baseMap", "flatMap_1", "applyHunk", "cursor", "mapChanges", "toValue", "changesByLineNumber", "_keyBy", "maxLineNumber", "from", "toTextPair", "_groupChanges", "_flatMap", "oldChanges", "newChanges", "_groupChanges2", "toText", "createRoot", "toTokenTrees", "oldSource", "newSource", "highlightText", "highlight", "refractor", "language", "_toTextPair2", "oldText", "newText", "toTree", "clone", "node", "leaf", "leafOf", "splitStart", "splitEnd", "wrapSplitNode", "parents", "body", "parent", "treeToPathList", "nodeToUse", "splitByLineBreak", "currentLine", "_splitPathToLines", "_splitPathToLines2", "_toArray", "currentRemaining", "nextLines", "normalizeToLines", "tree", "isEqualWith_1", "isEqual_1", "last_1", "attachNode", "previousSibling", "_last", "_isEqualWith", "_isEqual", "backToTree", "pathList", "_loop", "groupBy_1", "isEmpty_1", "splitPathToEncloseRange", "rangeEnd", "_paths$reduce", "nodeStart", "nodeEnd", "segments", "linesOfPaths", "ranges", "rangesByLine", "_groupBy", "_isEmpty", "pickRanges", "oldRanges", "newRanges", "oldLinesOfPaths", "newLinesOfPaths", "flatten_1", "findIndex_1", "diff_match_patch", "Diff_Timeout", "Diff_EditCost", "Match_Threshold", "Match_Distance", "Patch_DeleteThreshold", "Patch_Margin", "Match_MaxBits", "op", "diff_main", "text1", "text2", "opt_checklines", "opt_deadline", "Number", "MAX_VALUE", "Date", "getTime", "deadline", "checklines", "commonlength", "diff_commonPrefix", "commonprefix", "substring", "diff_commonSuffix", "commonsuffix", "diffs", "diff_compute_", "unshift", "diff_cleanupMerge", "longtext", "shorttext", "hm", "diff_halfMatch_", "text1_a", "text1_b", "text2_a", "text2_b", "mid_common", "diffs_a", "diffs_b", "diff_lineMode_", "diff_bisect_", "a", "diff_linesToChars_", "chars1", "chars2", "linearray", "lineArray", "diff_charsToLines_", "diff_cleanupSemantic", "pointer", "count_delete", "count_insert", "text_delete", "text_insert", "subDiff", "j", "text1_length", "text2_length", "max_d", "ceil", "v_offset", "v_length", "v1", "v2", "delta", "front", "k1start", "k1end", "k2start", "k2end", "d", "k1", "k1_offset", "y1", "x1", "k2_offset", "x2", "diff_bisectSplit_", "k2", "y2", "text1a", "text2a", "text1b", "text2b", "diffsb", "lineHash", "diff_linesToCharsMunge_", "chars", "lineStart", "lineEnd", "lineArrayLength", "fromCharCode", "maxLines", "pointermin", "pointermax", "pointermid", "pointerstart", "floor", "pointerend", "diff_commonOverlap_", "text_length", "best", "pattern", "found", "dmp", "diff_halfMatchI_", "best_longtext_a", "best_longtext_b", "best_shorttext_a", "best_shorttext_b", "seed", "best_common", "prefixLength", "suffixLength", "hm1", "hm2", "equalities", "equalitiesLength", "lastEquality", "length_insertions1", "length_deletions1", "length_insertions2", "length_deletions2", "diff_cleanupSemanticLossless", "deletion", "overlap_length1", "overlap_length2", "diff_cleanupSemanticScore_", "one", "two", "char1", "char2", "nonAlphaNumeric1", "nonAlphaNumericRegex_", "nonAlphaNumeric2", "whitespace1", "whitespaceRegex_", "whitespace2", "lineBreak1", "linebreakRegex_", "lineBreak2", "blankLine1", "blanklineEndRegex_", "blankLine2", "blanklineStartRegex_", "equality1", "edit", "equality2", "commonOffset", "commonString", "bestEquality1", "bestEdit", "bestEquality2", "bestScore", "score", "diff_cleanupEfficiency", "pre_ins", "pre_del", "post_ins", "post_del", "diff_xIndex", "loc", "last_chars1", "last_chars2", "diff_prettyHtml", "html", "pattern_amp", "pattern_lt", "pattern_gt", "pattern_para", "diff_text1", "diff_text2", "diff_levenshtein", "levenshtein", "insertions", "deletions", "diff_toDelta", "encodeURI", "diff_fromDelta", "diffsLength", "param", "decodeURI", "ex", "isNaN", "match_main", "match_bitap_", "match_alphabet_", "match_bitapScore_", "accuracy", "proximity", "abs", "score_threshold", "best_loc", "lastIndexOf", "bin_min", "bin_mid", "matchmask", "last_rd", "bin_max", "finish", "rd", "charMatch", "patch_addContext_", "patch", "start2", "length1", "padding", "suffix", "start1", "length2", "patch_make", "opt_b", "opt_c", "patches", "patch_obj", "patchDiffLength", "char_count1", "char_count2", "prepatch_text", "postpatch_text", "diff_type", "diff_text", "patch_deepCopy", "patchesCopy", "patchCopy", "patch_apply", "nullPadding", "patch_addPadding", "patch_splitMax", "results", "start_loc", "expected_loc", "end_loc", "index2", "index1", "mod", "paddingLength", "extraLength", "patch_size", "bigpatch", "precontext", "empty", "shift", "postcontext", "patch_toText", "patch_fromText", "textline", "textPointer", "patchHeader", "m", "sign", "DIFF_EQUAL", "DiffMatchPatch", "DIFF_DELETE", "DIFF_INSERT", "findChangeBlocks", "_findIndex", "splitDiffToLines", "_currentLines$map2", "currentLineRemaining", "diffsToEdits", "diff", "_output", "edits", "_diff2", "convertToLinesOfEdits", "linesOfDiffs", "startLineNumber", "oldDiffs", "newDiffs", "diffChangeBlock", "_ref6", "_changes$reduce2", "_diffText2", "getLineNumber", "oldStartLineNumber", "newStartLineNumber", "diffByLine", "_changes$reduce3", "_ref7", "currentChange", "_ref8", "oldEdits", "newEdits", "previousChange", "_diffText4", "_changes$reduce4", "markEdits", "_ref9$type", "findEdits", "_changeBlocks$map$red", "_ref10", "_ref11", "_ref12", "_ref13", "currentOld", "currentNew", "_changeBlocks$map$red2", "_flatten", "markWord", "word", "mark", "replacement", "tokenize", "pair", "_ref$enhancers", "enhancers", "_toTokenTrees2", "oldTokenTree", "newTokenTree", "_enhance", "input", "enhance", "_enhance2", "oldEnhanced", "newEnhanced", "newTrees", "_root$children", "new", "_root$children2", "useMinCollapsedLines", "minLinesExclusive", "updateCollection", "command", "filter", "useCollection", "_useReducer2", "useReducer", "dispatch", "toggle", "only", "useChangeSelect", "_ref$multiple", "multiple", "_useCollection", "useEffect", "useSourceExpansion", "expandedRanges", "linesOfOldSource", "shallowEqualObjects", "objA", "objB", "aKeys", "bKeys", "findAbnormalChanges", "defaultShouldTokenize", "prev", "yHunks", "currentHunks", "currentPayload", "prevHunks", "prevPayload", "arrA", "arrB", "useTokenizeWorker", "worker", "payload", "equals", "identifier", "_options$shouldTokeni", "shouldTokenize", "payloadIdentifier", "previous", "undefined", "tokenizationFailReason", "tokenizeResult", "setTokenizeResult", "job", "receiveTokens", "_ref$data", "success", "reason", "addEventListener", "removeEventListener", "postMessage", "wrapDisplayName", "BaseComponent", "hocName", "Component", "displayName", "withSourceExpansion", "ComponentIn", "ComponentOut", "_useSourceExpansion2", "renderingHunks", "expandRange", "onExpandRange", "minCollapsedLines", "withChangeSelect", "_useChangeSelect2", "toggleChangeSelection", "onToggleChangeSelection", "defaultMapPayload", "withTokenizeWorkerwithTokenizeWorker", "_options$mapPayload", "mapPayload", "hookOptions", "tokenizationResult"]
}
